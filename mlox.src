// scanner
TokenType = {
"LEFT_PAREN": "LEFT_PAREN",
"RIGHT_PAREN": "RIGHT_PAREN",
"LEFT_SQUARE": "LEFT_SQUARE",
"RIGHT_SQUARE": "RIGHT_SQUARE",
"LEFT_BRACE": "LEFT_BRACE",
"RIGHT_BRACE": "RIGHT_BRACE",
"COMMA": "COMMA",
"DOT": "DOT",
"MINUS": "MINUS",
"PLUS": "PLUS",
"MOD": "MOD",
"INCREMENT": "INCREMENT",
"DECREMENT": "DECREMENT",
"PLUS_ASSIGN": "PLUS_ASSIGN",
"MINUS_ASSIGN": "MINUS_ASSIGN",
"MUL_ASSIGN": "MUL_ASSIGN",
"DIV_ASSIGN": "DIV_ASSIGN",
"MOD_ASSIGN": "MOD_ASSIGN",
"COLON": "COLON",
"SEMICOLON": "SEMICOLON",
"SLASH": "SLASH",
"STAR": "STAR",
"BANG": "BANG",
"BANG_EQUAL": "BANG_EQUAL",
"EQUAL": "EQUAL",
"EQUAL_EQUAL": "EQUAL_EQUAL",
"GREATER": "GREATER",
"GREATER_EQUAL": "GREATER_EQUAL",
"LESS": "LESS",
"LESS_EQUAL": "LESS_EQUAL",
"IDENTIFIER": "IDENTIFIER",
"STRING": "STRING",
"NUMBER": "NUMBER",
"AND": "AND",
"CLASS": "CLASS",
"ELSE": "ELSE",
"FALSE": "FALSE",
"FUN": "FUN",
"LAMBDA": "LAMBDA",
"FOREACH": "FOREACH",
"IN": "IN",
"FOR": "FOR",
"SWITCH": "SWITCH",
"CASE": "CASE",
"DEFAULT": "DEFAULT",
"TRY": "TRY",
"CATCH": "CATCH",
"FINALLY": "FINALLY",
"THROW": "THROW",
"IF": "IF",
"QUESTION": "QUESTION",
"NIL": "NIL",
"OR": "OR",
"PRINT": "PRINT",
"RETURN": "RETURN",
"BREAK": "BREAK",
"CONTINUE": "CONTINUE",
"SUPER": "SUPER",
"THIS": "THIS",
"TRUE": "TRUE",
"VAR": "VAR",
"DO": "DO",
"WHILE": "WHILE",
"EOF": "EOF",
}
keywords = {
    "and": TokenType.AND,
    "class": TokenType.CLASS,
    "else": TokenType.ELSE,
    "false": TokenType.FALSE,
    "foreach": TokenType.FOREACH,
    "in": TokenType.IN,
    "for": TokenType.FOR,
    "fun": TokenType.FUN,
    "lambda": TokenType.LAMBDA,
    "switch": TokenType.SWITCH,
    "case": TokenType.CASE,
    "default": TokenType.DEFAULT,
    "try": TokenType.TRY,
    "catch": TokenType.CATCH,
    "finally": TokenType.FINALLY,
    "throw": TokenType.THROW,
    "if": TokenType.IF,
    "nil": TokenType.NIL,
    "or": TokenType.OR,
    "print": TokenType.PRINT,
    "return": TokenType.RETURN,
    "break": TokenType.BREAK,
    "continue": TokenType.CONTINUE,
    "super": TokenType.SUPER,
    "this": TokenType.THIS,
    "true": TokenType.TRUE,
    "var": TokenType.VAR,
    "do": TokenType.DO,
    "while": TokenType.WHILE,
}
// @type        token[0]
// @lexeme      token[1]
// @literal     token[2]
// @line        token[3]
NewToken = function(type, lexeme, literal, line)
    return [@type, @lexeme, @literal, @line, rnd]
end function
TokenToString = function(token)
    if @token[2] == null then return @token[0] + " " + @token[1]
    return @token[0] + " " + @token[1] + " " + @token[2]
end function
// @source          scanner[0]
// @tokens          scanner[1]
// @start           scanner[2]
// @current         scanner[3]
// @line            scanner[4]
NewScanner = function(source)
    return [@source, [], 0, 0, 1]
end function
ScannerIsAtEnd = function(scanner)
    return @scanner[3] >= scanner[0].len
end function
ScanTokens = function(scanner)
    while not ScannerIsAtEnd(@scanner)
        scanner[2] = @scanner[3]
        ScanToken(@scanner)
    end while

    scanner[1].push(NewToken(@TokenType.EOF, "", null, @scanner[4]))
    return @scanner[1]
end function
ScannerAdvance = function(scanner)
    c = scanner[0][@scanner[3]]
    scanner[3] = @scanner[3] + 1
    return @c
end function
AddToken = function(scanner, type, literal=null)
    text = @scanner[0][@scanner[2]:@scanner[3]]
    @scanner[1].push(NewToken(@type, @text, @literal, @scanner[4]))
end function
ScannerMatch = function(scanner, expected)
    if ScannerIsAtEnd(@scanner) then return false
    if @scanner[0][@scanner[3]] != @expected then return false

    @scanner[3] = @scanner[3] + 1
    return true
end function
ScannerPeek = function(scanner)
    if ScannerIsAtEnd(@scanner) then return ""
    return @scanner[0][@scanner[3]]
end function
ScannerString = function(scanner)
    while ScannerPeek(@scanner) != """" and not ScannerIsAtEnd(@scanner)
        if ScannerPeek(@scanner) == char(10) then @scanner[4] = @scanner[4] + 1
        ScannerAdvance(@scanner)
    end while    
    if ScannerIsAtEnd(@scanner) then
        LoxErrorLM(@scanner[4], "Unterminated string.")
        return
    end if

    ScannerAdvance(@scanner)

    value = @scanner[0][@scanner[2]+1:@scanner[3]-1]
    AddToken(@scanner, @TokenType.STRING, @value)
end function
ScannerNumber = function(scanner)
    while IsDigit(ScannerPeek(@scanner))
        ScannerAdvance(@scanner)
    end while

    if ScannerPeek(@scanner) == "." and IsDigit(ScannerPeekNext(@scanner)) then
        ScannerAdvance(@scanner)
        while IsDigit(ScannerPeek(@scanner))
            ScannerAdvance(@scanner)
        end while
    end if

    AddToken(@scanner, @TokenType.NUMBER, scanner[0][@scanner[2]:@scanner[3]].val)
end function
ScannerIdentifier = function(scanner)
    while IsAlphaNumeric(ScannerPeek(@scanner))
        ScannerAdvance(@scanner)
    end while

    text = @scanner[0][@scanner[2]:@scanner[3]]
    if keywords.hasIndex(@text) == false then
        type = @TokenType.IDENTIFIER
    else
        type = keywords[@text]
    end if
    AddToken(@scanner, @type)
end function
ScannerPeekNext = function(scanner)
    if @scanner[3] + 1 >= scanner[0].len then return ""
    return @scanner[0][@scanner[3] + 1]
end function
IsAlpha = function(c)
    return (@c >= "a" and @c <= "z") or (@c >= "A" and @c <= "Z") or @c == "_"
end function
IsAlphaNumeric = function(c)
    return IsAlpha(@c) or IsDigit(@c)
end function
IsDigit = function(c)
    return @c >= "0" and @c <= "9"
end function
ScanToken = function(scanner)
    c = ScannerAdvance(@scanner)
    if @c == "(" then
        AddToken(@scanner, @TokenType.LEFT_PAREN)
    else if @c == ")" then
        AddToken(@scanner, @TokenType.RIGHT_PAREN)
    else if @c == "[" then
        AddToken(@scanner, @TokenType.LEFT_SQUARE)
    else if @c == "]" then
        AddToken(@scanner, @TokenType.RIGHT_SQUARE)
    else if @c == "{" then
        AddToken(@scanner, @TokenType.LEFT_BRACE)
    else if @c == "}" then
        AddToken(@scanner, @TokenType.RIGHT_BRACE)
    else if @c == "," then
        AddToken(@scanner, @TokenType.COMMA)
    else if @c == "." then
        AddToken(@scanner, @TokenType.DOT)
    else if @c == "?" then
        AddToken(@scanner, @TokenType.QUESTION)
    else if @c == "-" then
        if ScannerMatch(@scanner, "-") then
            AddToken(@scanner, @TokenType.DECREMENT)
        else if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.MINUS_ASSIGN)
        else
            AddToken(@scanner, @TokenType.MINUS)
        end if
    else if @c == "+" then
        if ScannerMatch(@scanner, "+") then
            AddToken(@scanner, @TokenType.INCREMENT)
        else if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.PLUS_ASSIGN)
        else
            AddToken(@scanner, @TokenType.PLUS)
        end if
    else if @c == ":" then
        AddToken(@scanner, @TokenType.COLON)
    else if @c == ";" then
        AddToken(@scanner, @TokenType.SEMICOLON)
    else if @c == "%" then
        if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.MOD_ASSIGN)
        else
            AddToken(@scanner, @TokenType.MOD)
        end if
    else if @c == "*" then
        if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.MUL_ASSIGN)
        else
            AddToken(@scanner, @TokenType.STAR)
        end if
    else if @c == "!" then
        if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.BANG_EQUAL)
        else
            AddToken(@scanner, @TokenType.BANG)
        end if
    else if @c == "=" then
        if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.EQUAL_EQUAL)
        else
            AddToken(@scanner, @TokenType.EQUAL)
        end if
    else if @c == "<" then
        if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.LESS_EQUAL)
        else
            AddToken(@scanner, @TokenType.LESS)
        end if
    else if @c == ">" then
        if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.GREATER_EQUAL)
        else
            AddToken(@scanner, @TokenType.GREATER)
        end if
    else if @c == "/" then
        if ScannerMatch(@scanner, "/") then
            while ScannerPeek(@scanner) != char(10) and not ScannerIsAtEnd(@scanner)
                ScannerAdvance(@scanner)
            end while
        else if ScannerMatch(@scanner, "=") then
            AddToken(@scanner, @TokenType.DIV_ASSIGN)
        else
            AddToken(@scanner, @TokenType.SLASH)
        end if
    else if @c == " " or @c == char(13) or @c == char(9) then
        // Ignore whitespace.
    else if c == char(10) then
        @scanner[4] = @scanner[4] + 1
    else if c == """" then
        ScannerString(@scanner)
    else if IsDigit(@c) then
        ScannerNumber(@scanner)
    else if IsAlpha(@c) then
        ScannerIdentifier(@scanner)
    else
        Error(@scanner[4], "Unexpected character.")
    end if
end function
// expr
// @throwable
ExprAccept = function(expr, visitor)
    case = @expr[0]
    if case == "Assign" then return VisitorVisitAssignExpr(@visitor, @expr)
    if case == "Binary" then return VisitorVisitBinaryExpr(@visitor, @expr)
    if case == "Ternary" then return VisitorVisitTenaryExpr(@visitor, @expr)
    if case == "Call" then return VisitorVisitCallExpr(@visitor, @expr)
    if case == "Get" then return VisitorVisitGetExpr(@visitor, @expr)
    if case == "Subscript" then return VisitorVisitSubscriptExpr(@visitor, @expr)
    if case == "Slice" then return VisitorVisitSliceExpr(@visitor, @expr)
    if case == "Grouping" then return VisitorVisitGroupingExpr(@visitor, @expr)
    if case == "Literal" then return VisitorVisitLiteralExpr(@visitor, @expr)
    if case == "Lambda" then return VisitorVisitLambdaExpr(@visitor, @expr)
    if case == "List" then return VisitorVisitListExpr(@visitor, @expr)
    if case == "Map" then return VisitorVisitMapExpr(@visitor, @expr)
    if case == "Logical" then return VisitorVisitLogicalExpr(@visitor, @expr)
    if case == "Set" then return VisitorVisitSetExpr(@visitor, @expr)
    if case == "SubscriptSet" then return VisitorVisitSubscriptSetExpr(@visitor, @expr)
    if case == "Super" then return VisitorVisitSuperExpr(@visitor, @expr)
    if case == "This" then return VisitorVisitThisExpr(@visitor, @expr)
    if case == "Unary" then return VisitorVisitUnaryExpr(@visitor, @expr)
    if case == "Postfix" then return VisitorVisitPostfixExpr(@visitor, @expr)
    if case == "Prefix" then return VisitorVisitPrefixExpr(@visitor, @expr)
    if case == "Variable" then return VisitorVisitVariableExpr(@visitor, @expr)
end function
// assign
// @name        expr[1] Token
// @value       expr[2] Expr
NewAssignExpr = function(_name, value)
    return ["Assign", @_name, @value, rnd]
end function
// ternary
// @condition   expr[1] Expr
// @thenBranch  expr[2] Expr
// @elseBranch  expr[3] Expr
NewTenaryExpr = function(condition, thenBranch, elseBranch)
    return ["Ternary", @condition, @thenBranch, @elseBranch, rnd]
end function
// binary
// @left        expr[1] Expr
// @operator    expr[2] Token
// @right       expr[3] Expr
NewBinaryExpr = function(left, operator, right)
    return ["Binary", @left, @operator, @right, rnd]
end function
// call
// @callee      expr[1] Expr
// @paren       expr[2] Token
// @arguments   expr[3] Expr[]
NewCallExpr = function(callee, paren, arguments)
    return ["Call", @callee, @paren, @arguments, rnd]
end function
// get
// @object      expr[1] Expr
// @name        expr[2] Token
NewGetExpr = function(object, _name)
    return ["Get", @object, @_name, rnd]
end function
// subscript
// @object      expr[1] Expr
// @index       expr[2] Expr
// @name        expr[3] Token
NewSubscriptExpr = function(object, index, _name)
    return ["Subscript", @object, @index, @_name, rnd]
end function
// slice
// @object      expr[1] Expr
// @start       expr[2] Expr
// @end         expr[3] Expr
// @name        expr[4] Token
NewSliceExpr = function(object, start, _end, _name)
    return ["Slice", @object, @start, @_end, @_name, rnd]
end function
// group
// @expression  expr[1] Expr
NewGroupingExpr = function(expression)
    return ["Grouping", @expression, rnd]
end function
// literal
// @value       expr[1] Object
NewLiteralExpr = function(value)
    return ["Literal", @value, rnd]
end function
// logical
// @left        expr[1] Expr
// @operator    expr[2] Token
// @right       expr[3] Expr
NewLogicalExpr = function(left, operator, right)
    return ["Logical", @left, @operator, @right, rnd]
end function
// set
// @object      expr[1] Expr
// @name        expr[2] Token
// @value       expr[3] Expr
NewSetExpr = function(object, _name, value)
    return ["Set", @object, @_name, @value, rnd]
end function
// subscriptSet
// @object      expr[1] Expr
// @index       expr[2] Expr
// @value       expr[3] Expr
// @name        expr[4] Token
NewSubscriptSetExpr = function(object, index, value, _name)
    return ["SubscriptSet", @object, @index, @value, @_name, rnd]
end function
// super
// @keyword    expr[1] Token
// @method     expr[2] Token
NewSuperExpr = function(keyword, method)
    return ["Super", @keyword, @method, rnd]
end function
// this
// @keyword    expr[1] Token
NewThisExpr = function(keyword)
    return ["This", @keyword, rnd]
end function
// unary
// @operator    expr[1] Token
// @right       expr[2] Expr
NewUnaryExpr = function(operator, right)
    return ["Unary", @operator, @right, rnd]
end function
// postfix
// @value       expr[1] Expr
// @operator    expr[2] Token
// @assignStmt  expr[3] Stmt
NewPostfixExpr = function(value, operator, assignStmt)
    return ["Postfix", @value, @operator, @assignStmt, rnd]
end function
// prefix
// @value      expr[1] Expr
// @operator   expr[2] Token
// @assignStmt expr[3] Stmt
NewPrefixExpr = function(value, operator, assignStmt)
    return ["Prefix", @value, @operator, @assignStmt, rnd]
end function
// variable
// @name        expr[1] Token
NewVariableExpr = function(_name)
    return ["Variable", @_name, rnd]
end function
// lambda
// @name        expr[1] Token
// @parameters  expr[2] Token[]
// @body        expr[3] Stmt[]
NewLambdaExpr = function(_name, parameters, body)
    return ["Lambda", @_name, @parameters, @body, rnd]
end function
// list
// @values      expr[1] Expr[]
NewListExpr = function(_values)
    return ["List", @_values, rnd]
end function
// map
// @values      expr[1] Map
NewMapExpr = function(_values)
    return ["Map", @_values, rnd]
end function
// parser
// @tokens      parser[0]
// @current     parser[1]
NewParser = function(tokens)
    return [tokens, 0]
end function
// @throwable
Parse = function(parser)
    statements = []
    while not ParserIsAtEnd(@parser)
        statements.push(ParserDeclaration(@parser))
    end while
    return @statements
end function
ParserExpression = function(parser)
    return ParserAssignment(@parser)
end function
// @catchable
// @throwable
ParserDeclaration = function(parser)
    if ParserMatch(@parser, [@TokenType.CLASS]) then
        throw = ParserClassDeclaration(@parser)
        if @throw isa @ParseError then 
            ParserSynchronize(@parser)
            return null
        else
            return @throw
        end if
    end if
    if ParserMatch(@parser, [@TokenType.FUN]) then
        throw = ParserFunction(@parser, "function")
        if @throw isa @ParseError then 
            ParserSynchronize(@parser)
            return null
        else
            return @throw
        end if
    end if
    if ParserMatch(@parser, [@TokenType.VAR]) then
        throw = ParserVarDeclaration(@parser)
        if @throw isa @ParseError then 
            ParserSynchronize(@parser)
            return null
        else
            return @throw
        end if
    end if
    throw = ParserStatement(@parser)
    if @throw isa @ParseError then 
        ParserSynchronize(@parser)
        return null
    else
        return @throw
    end if
end function
// @throwable
ParserClassDeclaration = function(parser)
    _name = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect class name.")
    if @_name isa @RuntimeException then return @_name

    superclass = null
    if ParserMatch(@parser, [@TokenType.LESS]) then
        throw = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect superclass name.")
        if @throw isa @RuntimeException then return @throw
        superclass = NewVariableExpr(ParserPrevious(@parser))
    end if

    throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' before class body.")
    if @throw isa @RuntimeException then return @throw

    methods = []
    while not ParserCheck(@parser, @TokenType.RIGHT_BRACE) and not ParserIsAtEnd(@parser)
        method = ParserFunction(@parser, "method")
        if @method isa @RuntimeException then return @method
        methods.push(@method)
    end while

    throw = ParserConsume(@parser, @TokenType.RIGHT_BRACE, "Expect '}' after class body.")
    if @throw isa @RuntimeException then return @throw
    return NewClassStmt(@_name, @superclass, @methods)
end function
// @throwable
ParserStatement = function(parser)
    if ParserMatch(@parser, [@TokenType.FOREACH]) then return ParserForeachStatement(@parser)
    if ParserMatch(@parser, [@TokenType.FOR]) then return ParserForStatement(@parser)
    if ParserMatch(@parser, [@TokenType.SWITCH]) then return ParserSwitchStatement(@parser)
    if ParserMatch(@parser, [@TokenType.TRY]) then return ParserTryStatement(@parser)
    if ParserMatch(@parser, [@TokenType.THROW]) then return ParserThrowStatement(@parser)
    if ParserMatch(@parser, [@TokenType.IF]) then return ParserIfStatement(@parser)
    if ParserMatch(@parser, [@TokenType.PRINT]) then return ParserPrintStatement(@parser)
    if ParserMatch(@parser, [@TokenType.RETURN]) then return ParserReturnStatement(@parser)
    if ParserMatch(@parser, [@TokenType.BREAK]) then return ParserBreakStatement(@parser)
    if ParserMatch(@parser, [@TokenType.CONTINUE]) then return ParserContinueStatement(@parser)
    if ParserMatch(@parser, [@TokenType.DO]) then return ParserDoWhileStatement(@parser)
    if ParserMatch(@parser, [@TokenType.WHILE]) then return ParserWhileStatement(@parser)
    if ParserMatch(@parser, [@TokenType.LEFT_BRACE]) then
        throw = ParserBlock(@parser)
        if @throw isa @RuntimeException then return @throw
        return NewBlockStmt(@throw)
    end if
    return ParserExpressionStatement(@parser)
end function
// @throwable
ParserForeachStatement = function(parser)
    throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after 'foreach'.")
    if @throw isa @RuntimeException then return @throw
    
    _throw = ParserConsume(@parser, @TokenType.VAR, "Expect 'var' after 'foreach'.")
    if @_throw isa @RuntimeException then return @_throw

    _name = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect variable name.")
    if @_name isa @RuntimeException then return @_name

    throw = ParserConsume(@parser, @TokenType.IN, "Expect 'in' after variable name.")
    if @throw isa @RuntimeException then return @throw

    iterable = ParserExpression(@parser)
    if @iterable isa @RuntimeException then return @iterable

    throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after foreach clauses.")
    if @throw isa @RuntimeException then return @throw

    body = ParserStatement(@parser)
    if @body isa @RuntimeException then return @body

    return NewForeachStmt(@_name, @iterable, @body)
end function
// @throwable
ParserForStatement = function(parser)
    throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after 'for'.")
    if @throw isa @RuntimeException then return @throw

    initializer = null
    if ParserMatch(@parser, [@TokenType.SEMICOLON]) then
        initializer = null
    else if ParserMatch(@parser, [@TokenType.VAR]) then
        initializer = ParserVarDeclaration(@parser)
        if @initializer isa @RuntimeException then return @initializer
    else
        initializer = ParserExpressionStatement(@parser)
        if @initializer isa @RuntimeException then return @initializer
    end if

    condition = null
    if not ParserCheck(@parser, @TokenType.SEMICOLON) then
        condition = ParserExpression(@parser)
        if @condition isa @RuntimeException then return @condition
    end if
    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after loop condition.")
    if @throw isa @RuntimeException then return @throw

    increment = null
    if not ParserCheck(@parser, @TokenType.RIGHT_PAREN) then
        increment = ParserExpression(@parser)
        if @increment isa @RuntimeException then return @increment
    end if
    throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after for clauses.")
    if @throw isa @RuntimeException then return @throw

    body = ParserStatement(@parser)
    if @body isa @RuntimeException then return @body

    if @increment != null then
        body = NewBlockStmt([@body, NewExpressionStmt(@increment)])
    end if

    if @condition == null then
        @condition = NewLiteralExpr(true)
    end if
    body = NewWhileStmt(@condition, @body)

    if @initializer != null then
        body = NewBlockStmt([@initializer, @body])
    end if

    return @body
end function
// @throwable
ParserSwitchStatement = function(parser)
    throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after 'switch'.")
    if @throw isa @RuntimeException then return @throw

    swictchValue = ParserExpression(@parser)
    if @swictchValue isa @RuntimeException then return @swictchValue

    throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after switch value.")
    if @throw isa @RuntimeException then return @throw

    throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' before switch cases.")
    if @throw isa @RuntimeException then return @throw

    conditions = []
    bodies = []
    default = null
    while not ParserCheck(@parser, @TokenType.RIGHT_BRACE)
        if ParserMatch(@parser, [@TokenType.CASE]) then
            value = ParserExpression(@parser)
            if @value isa @RuntimeException then return @value

            throw = ParserConsume(@parser, @TokenType.COLON, "Expect ':' after case value.")
            if @throw isa @RuntimeException then return @throw

            statements = []
            while not ParserCheck(@parser, @TokenType.CASE) and not ParserCheck(@parser, @TokenType.DEFAULT) and not ParserCheck(@parser, @TokenType.RIGHT_BRACE)
                throw = ParserDeclaration(@parser)
                if @throw isa @RuntimeException then return @throw
                statements.push(@throw)
            end while

            conditions.push(@value)
            bodies.push(@statements)
        else if ParserMatch(@parser, [@TokenType.DEFAULT]) then
            if @default != null then
                ParserError(ParserPeek(@parser), "Cannot have multiple default cases in one switch statement.")
            end if

            throw = ParserConsume(@parser, @TokenType.COLON, "Expect ':' after 'default'.")
            if @throw isa @RuntimeException then return @throw

            statements = []
            while not ParserCheck(@parser, @TokenType.RIGHT_BRACE)
                throw = ParserDeclaration(@parser)
                if @throw isa @RuntimeException then return @throw
                statements.push(@throw)
            end while

            if not ParserCheck(@parser, @TokenType.RIGHT_BRACE) then
                ParserError(ParserPeek(@parser), "Expect '}' after default case.")
            end if
            
            default = @statements
        else
            ParserError(ParserPeek(@parser), "Expect 'case' or 'default' in switch statement.")
        end if
    end while

    throw = ParserConsume(@parser, @TokenType.RIGHT_BRACE, "Expect '}' after switch cases.")
    if @throw isa @RuntimeException then return @throw

    return NewSwitchStmt(@swictchValue, @conditions, @bodies, @default)
end function
// @throwable
ParserTryStatement = function(parser)
    throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' after 'try'.")
    if @throw isa @RuntimeException then return @throw

    tryBody = ParserBlock(@parser)
    if @tryBody isa @RuntimeException then return @tryBody

    catchValue = null
    catchBody = null
    finallyBody = null
    if ParserMatch(@parser, [@TokenType.CATCH]) then
        if ParserCheck(@parser, @TokenType.LEFT_BRACE) then
            throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' after 'catch'.")
            if @throw isa @RuntimeException then return @throw
    
            catchBody = ParserBlock(@parser)
            if @catchBody isa @RuntimeException then return @catchBody
        else
            throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after 'catch'.")
            if @throw isa @RuntimeException then return @throw
    
            throw = ParserConsume(@parser, @TokenType.VAR, "Expect 'var' after 'catch'.")
            if @throw isa @RuntimeException then return @throw
    
            catchValue = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect identifier after 'catch'.")
            if @catchValue isa @RuntimeException then return @catchValue
    
            throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after catch value.")
            if @throw isa @RuntimeException then return @throw
    
            throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' after 'catch'.")
            if @throw isa @RuntimeException then return @throw
    
            catchBody = ParserBlock(@parser)
            if @catchBody isa @RuntimeException then return @catchBody
        end if
    end if

    if ParserMatch(@parser, [@TokenType.FINALLY]) then
        throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' after 'finally'.")
        if @throw isa @RuntimeException then return @throw

        finallyBody = ParserBlock(@parser)
        if @finallyBody isa @RuntimeException then return @finallyBody
    end if

    if @catchBody == null and @finallyBody == null then
        ParserError(ParserPeek(@parser), "Expect 'catch' or 'finally' after 'try'.")
    end if

    if @tryBody != null then tryBody = NewBlockStmt(@tryBody)

    if @catchBody != null then catchBody = NewBlockStmt(@catchBody)

    if @finallyBody != null then finallyBody = NewBlockStmt(@finallyBody)

    return NewTryStmt(@tryBody, @catchValue, @catchBody, @finallyBody)
end function
// @throwable
ParserThrowStatement = function(parser)
    value = ParserExpression(@parser)
    if @value isa @RuntimeException then return @value

    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after throw value.")
    if @throw isa @RuntimeException then return @throw

    return NewThrowStmt(@value)
end function
// @throwable
ParserIfStatement = function(parser)
    throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after 'if'.")
    if @throw isa @RuntimeException then return @throw

    condition = ParserExpression(@parser)
    if @condition isa @RuntimeException then return @condition

    throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after if condition.")
    if @throw isa @RuntimeException then return @throw

    thenBranch = ParserStatement(@parser)
    if @thenBranch isa @RuntimeException then return @thenBranch

    elseBranch = null
    if ParserMatch(@parser, [@TokenType.ELSE]) then
        // else if 
        if ParserMatch(@parser, [@TokenType.IF]) then
            elseBranch = ParserIfStatement(@parser)
            if @elseBranch isa @RuntimeException then return @elseBranch
        else
            elseBranch = ParserStatement(@parser)
            if @elseBranch isa @RuntimeException then return @elseBranch
        end if
    end if

    return NewIfStmt(@condition, @thenBranch, @elseBranch)
end function
// @throwable
ParserPrintStatement = function(parser)
    value = ParserExpression(@parser)
    if @value isa @RuntimeException then return @value

    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after value.")
    if @throw isa @RuntimeException then return @throw

    return NewPrintStmt(@value)
end function
// @throwable
ParserReturnStatement = function(parser)
    keyword = ParserPrevious(@parser)
    value = null
    if not ParserCheck(@parser, @TokenType.SEMICOLON) then
        value = ParserExpression(@parser)
        if @value isa @RuntimeException then return @value
    end if

    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after return value.")
    if @throw isa @RuntimeException then return @throw

    // check if the return statement is a tail call
    isTailCall = value != null and value[0] == "Call"
    return NewReturnStmt(@keyword, @value, isTailCall)
end function
// @throwable
ParserBreakStatement = function(parser)
    keyword = ParserPrevious(@parser)
    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after break.")
    if @throw isa @RuntimeException then return @throw
    return NewBreakStmt(@keyword)
end function
// @throwable
ParserContinueStatement = function(parser)
    keyword = ParserPrevious(@parser)
    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after continue.")
    if @throw isa @RuntimeException then return @throw
    return NewContinueStmt(@keyword)
end function
// @throwable
ParserVarDeclaration = function(parser)
    _name = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect variable name.")
    if @_name isa @RuntimeException then return @_name

    initializer = null
    if ParserMatch(@parser, [@TokenType.EQUAL]) then
        initializer = ParserExpression(@parser)
        if @initializer isa @RuntimeException then return @initializer
    end if

    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after variable declaration.")
    if @throw isa @RuntimeException then return @throw

    return NewVarStmt(@_name, @initializer)
end function
// @throwable
ParserDoWhileStatement = function(parser)
    body = ParserStatement(@parser)
    if @body isa @RuntimeException then return @body

    throw = ParserConsume(@parser, @TokenType.WHILE, "Expect 'while' after 'do' body.")
    if @throw isa @RuntimeException then return @throw

    throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after 'while'.")
    if @throw isa @RuntimeException then return @throw
    
    condition = ParserExpression(@parser)
    if @condition isa @RuntimeException then return @condition

    throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after condition.")
    if @throw isa @RuntimeException then return @throw

    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after do-while statement.")
    if @throw isa @RuntimeException then return @throw

    return NewDoWhileStmt(@condition, @body)
end function
// @throwable
ParserWhileStatement = function(parser)
    throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after 'while'.")
    if @throw isa @RuntimeException then return @throw

    condition = ParserExpression(@parser)
    if @condition isa @RuntimeException then return @condition

    throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after condition.")
    if @throw isa @RuntimeException then return @throw

    body = ParserStatement(@parser)
    if @body isa @RuntimeException then return @body

    return NewWhileStmt(@condition, @body)
end function
// @throwable
ParserExpressionStatement = function(parser)
    expr = ParserExpression(@parser)
    if @expr isa @RuntimeException then return @expr
    
    throw = ParserConsume(@parser, @TokenType.SEMICOLON, "Expect ';' after expression.")
    if @throw isa @RuntimeException then return @throw

    return NewExpressionStmt(@expr)
end function
// @throwable
ParserFunction = function(parser, kind)
    _name = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect " + @kind + " name.")
    if @_name isa @RuntimeException then return @_name

    throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after " + @kind + " name.")
    if @throw isa @RuntimeException then return @throw

    parameters = []
    if not ParserCheck(@parser, @TokenType.RIGHT_PAREN) then
        // do-while
        if parameters.len >= 255 then
            ParserError(ParserPeek(@parser), "Cannot have more than 255 parameters.")
        end if
        throw = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect parameter name.")
        if @throw isa @RuntimeException then return @throw
        parameters.push(@throw)
        while ParserMatch(@parser, [@TokenType.COMMA])
            if parameters.len >= 255 then
                ParserError(ParserPeek(@parser), "Cannot have more than 255 parameters.")
            end if
            throw = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect parameter name.")
            if @throw isa @RuntimeException then return @throw
            parameters.push(@throw)
        end while
    end if

    throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after parameters.")
    if @throw isa @RuntimeException then return @throw

    throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' before " + @kind + " body.")
    if @throw isa @RuntimeException then return @throw
    
    body = ParserBlock(@parser)
    if @body isa @RuntimeException then return @body

    return NewFunctionStmt(@_name, @parameters, @body)
end function
// @throwable
ParserBlock = function(parser)
    statements = []
    while not ParserCheck(@parser, @TokenType.RIGHT_BRACE) and not ParserIsAtEnd(@parser)
        statements.push(ParserDeclaration(@parser))
    end while

    throw = ParserConsume(@parser, @TokenType.RIGHT_BRACE, "Expect '}' after block.")
    if @throw isa @RuntimeException then return @throw
    return @statements
end function
// @throwable
ParserAssignment = function(parser)
    expr = ParserTenary(@parser)
    if @expr isa @RuntimeException then return @expr

    if ParserMatch(@parser, [@TokenType.EQUAL, @TokenType.PLUS_ASSIGN, @TokenType.MINUS_ASSIGN, @TokenType.MUL_ASSIGN, @TokenType.DIV_ASSIGN, @TokenType.MOD_ASSIGN]) then
        equals = ParserPrevious(@parser)
        value = ParserAssignment(@parser)
        if @value isa @RuntimeException then return @value

        if @expr[0] == "Variable" then
            _name = @expr[1]
            if @equals[0] == "EQUAL" then
                return NewAssignExpr(@_name, @value)
            else if @equals[0] == "PLUS_ASSIGN" then
                return NewAssignExpr(@_name, NewBinaryExpr(@expr, NewToken(@TokenType.PLUS, "+", null, @equals[3]), @value))
            else if @equals[0] == "MINUS_ASSIGN" then
                return NewAssignExpr(@_name, NewBinaryExpr(@expr, NewToken(@TokenType.MINUS, "-", null, @equals[3]), @value))
            else if @equals[0] == "MUL_ASSIGN" then
                return NewAssignExpr(@_name, NewBinaryExpr(@expr, NewToken(@TokenType.STAR, "*", null, @equals[3]), @value))
            else if @equals[0] == "DIV_ASSIGN" then
                return NewAssignExpr(@_name, NewBinaryExpr(@expr, NewToken(@TokenType.SLASH, "/", null, @equals[3]), @value))
            else if @equals[0] == "MOD_ASSIGN" then
                return NewAssignExpr(@_name, NewBinaryExpr(@expr, NewToken(@TokenType.MOD, "%", null, @equals[3]), @value))
            end if
        else if @expr[0] == "Get" then
            get = @expr
            if @equals[0] == "EQUAL" then
                return NewSetExpr(@get[1], @get[2], @value)
            else if @equals[0] == "PLUS_ASSIGN" then
                return NewSetExpr(@get[1], @get[2], NewBinaryExpr(NewGetExpr(@get[1], @get[2]), NewToken(@TokenType.PLUS, "+", null, @equals[3]), @value))
            else if @equals[0] == "MINUS_ASSIGN" then
                return NewSetExpr(@get[1], @get[2], NewBinaryExpr(NewGetExpr(@get[1], @get[2]), NewToken(@TokenType.MINUS, "-", null, @equals[3]), @value))
            else if @equals[0] == "MUL_ASSIGN" then
                return NewSetExpr(@get[1], @get[2], NewBinaryExpr(NewGetExpr(@get[1], @get[2]), NewToken(@TokenType.STAR, "*", null, @equals[3]), @value))
            else if @equals[0] == "DIV_ASSIGN" then
                return NewSetExpr(@get[1], @get[2], NewBinaryExpr(NewGetExpr(@get[1], @get[2]), NewToken(@TokenType.SLASH, "/", null, @equals[3]), @value))
            else if @equals[0] == "MOD_ASSIGN" then
                return NewSetExpr(@get[1], @get[2], NewBinaryExpr(NewGetExpr(@get[1], @get[2]), NewToken(@TokenType.MOD, "%", null, @equals[3]), @value))
            end if
        else if @expr[0] == "Subscript" then
            subscript = @expr
            if @equals[0] == "EQUAL" then
                return NewSubscriptSetExpr(@subscript[1], @subscript[2], @value, @subscript[3])
            else if @equals[0] == "PLUS_ASSIGN" then
                return NewSubscriptSetExpr(@subscript[1], @subscript[2], NewBinaryExpr(NewSubscriptExpr(@subscript[1], @subscript[2], @subscript[3]), NewToken(@TokenType.PLUS, "+", null, @equals[3]), @value), @subscript[3])
            else if @equals[0] == "MINUS_ASSIGN" then
                return NewSubscriptSetExpr(@subscript[1], @subscript[2], NewBinaryExpr(NewSubscriptExpr(@subscript[1], @subscript[2], @subscript[3]), NewToken(@TokenType.MINUS, "-", null, @equals[3]), @value), @subscript[3])
            else if @equals[0] == "MUL_ASSIGN" then
                return NewSubscriptSetExpr(@subscript[1], @subscript[2], NewBinaryExpr(NewSubscriptExpr(@subscript[1], @subscript[2], @subscript[3]), NewToken(@TokenType.STAR, "*", null, @equals[3]), @value), @subscript[3])
            else if @equals[0] == "DIV_ASSIGN" then
                return NewSubscriptSetExpr(@subscript[1], @subscript[2], NewBinaryExpr(NewSubscriptExpr(@subscript[1], @subscript[2], @subscript[3]), NewToken(@TokenType.SLASH, "/", null, @equals[3]), @value), @subscript[3])
            else if @equals[0] == "MOD_ASSIGN" then
                return NewSubscriptSetExpr(@subscript[1], @subscript[2], NewBinaryExpr(NewSubscriptExpr(@subscript[1], @subscript[2], @subscript[3]), NewToken(@TokenType.MOD, "%", null, @equals[3]), @value), @subscript[3])
            end if
        end if

        ParserError(@equals, "Invalid assignment target.")
    end if

    return @expr
end function
// @throwable
ParserTenary = function(parser)
    expr = ParserOr(@parser)
    if @expr isa @RuntimeException then return @expr

    if ParserMatch(@parser, [@TokenType.QUESTION]) then
        thenBranch = ParserExpression(@parser)
        if @thenBranch isa @RuntimeException then return @thenBranch

        throw = ParserConsume(@parser, @TokenType.COLON, "Expect ':' after then branch.")
        if @throw isa @RuntimeException then return @throw

        elseBranch = ParserTenary(@parser)
        if @elseBranch isa @RuntimeException then return @elseBranch

        return NewTenaryExpr(@expr, @thenBranch, @elseBranch)
    end if

    return @expr
end function
// @throwable
ParserOr = function(parser)
    expr = ParserAnd(@parser)
    if @expr isa @RuntimeException then return @expr

    while ParserMatch(@parser, [@TokenType.OR])
        operator = ParserPrevious(@parser)
        right = ParserAnd(@parser)
        if @right isa @RuntimeException then return @right
        expr = NewLogicalExpr(@expr, @operator, @right)
    end while

    return @expr
end function
// @throwable
ParserAnd = function(parser)
    expr = ParserEquality(@parser)
    if @expr isa @RuntimeException then return @expr

    while ParserMatch(@parser, [@TokenType.AND])
        operator = ParserPrevious(@parser)
        right = ParserEquality(@parser)
        if @right isa @RuntimeException then return @right
        expr = NewLogicalExpr(@expr, @operator, @right)
    end while

    return @expr
end function
// @throwable
ParserEquality = function(parser)
    expr = ParserComparison(@parser)
    if @expr isa @RuntimeException then return @expr

    while ParserMatch(@parser, [@TokenType.BANG_EQUAL, @TokenType.EQUAL_EQUAL])
        operator = ParserPrevious(@parser)
        right = ParserComparison(@parser)
        if @right isa @RuntimeException then return @right
        expr = NewBinaryExpr(@expr, @operator, @right)
    end while

    return @expr
end function
// @throwable
ParserComparison = function(parser)
    expr = ParserTerm(@parser)
    if @expr isa @RuntimeException then return @expr

    while ParserMatch(@parser, [@TokenType.GREATER, @TokenType.GREATER_EQUAL, @TokenType.LESS, @TokenType.LESS_EQUAL])
        operator = ParserPrevious(@parser)
        right = ParserTerm(@parser)
        if @right isa @RuntimeException then return @right
        expr = NewBinaryExpr(@expr, @operator, @right)
    end while

    return @expr
    
end function
// @throwable
ParserTerm = function(parser)
    expr = ParserFactor(@parser)
    if @expr isa @RuntimeException then return @expr

    while ParserMatch(@parser, [@TokenType.MINUS, @TokenType.PLUS])
        operator = ParserPrevious(@parser)
        right = ParserFactor(@parser)
        if @right isa @RuntimeException then return @right
        expr = NewBinaryExpr(@expr, @operator, @right)
    end while

    return @expr
end function
// @throwable
ParserFactor = function(parser)
    expr = ParserUnary(@parser)
    if @expr isa @RuntimeException then return @expr

    while ParserMatch(@parser, [@TokenType.SLASH, @TokenType.STAR, @TokenType.MOD])
        operator = ParserPrevious(@parser)
        right = ParserUnary(@parser)
        if @right isa @RuntimeException then return @right
        expr = NewBinaryExpr(@expr, @operator, @right)
    end while

    return @expr
end function
// @throwable
ParserUnary = function(parser)
    if ParserMatch(@parser, [@TokenType.BANG, @TokenType.MINUS]) then
        operator = ParserPrevious(@parser)
        right = ParserUnary(@parser)
        if @right isa @RuntimeException then return @right
        return NewUnaryExpr(@operator, @right)
    end if
    return ParserIncrement(@parser)
end function
// @throwable
ParserIncrement = function(parser)
    if ParserMatch(@parser, [@TokenType.INCREMENT, @TokenType.DECREMENT]) then
        operator = ParserPrevious(@parser)
        if @operator[0] == "INCREMENT" then
            assignOp = NewToken(@TokenType.PLUS, "+", null, @operator[3])
        else if @operator[0] == "DECREMENT" then
            assignOp = NewToken(@TokenType.MINUS, "-", null, @operator[3])
        end if

        expr = ParserCall(@parser)
        if @expr isa @RuntimeException then return @expr

        if @expr[0] == "Variable" then
            _name = @expr
        
            assign = NewAssignExpr(@_name[1], NewBinaryExpr(@expr, assignOp, NewLiteralExpr(1)))
            return NewPrefixExpr(@_name, @operator, @assign)
        end if
        if @expr[0] == "Get" then
            get = @expr
            assign = NewSetExpr(@get[1], @get[2], NewBinaryExpr(NewGetExpr(@get[1], @get[2]), assignOp, NewLiteralExpr(1)))

            return NewPrefixExpr(@get, @operator, @assign)
        end if
        if @expr[0] == "Subscript" then
            subscript = @expr

            assign = NewSubscriptSetExpr(@subscript[1], @subscript[2], NewBinaryExpr(NewSubscriptExpr(@subscript[1], @subscript[2], @subscript[3]), assignOp, NewLiteralExpr(1)), @subscript[3])

            return NewPrefixExpr(@subscript, @operator, @assign)
        end if

        ParserError(@operator, "Invalid increment target.")
    end if

    expr = ParserCall(@parser)
    if @expr isa @RuntimeException then return @expr

    if ParserMatch(@parser, [@TokenType.INCREMENT, @TokenType.DECREMENT]) then
        operator = ParserPrevious(@parser)
        if @operator[0] == "INCREMENT" then
            assignOp = NewToken(@TokenType.PLUS, "+", null, @operator[3])
        else if @operator[0] == "DECREMENT" then
            assignOp = NewToken(@TokenType.MINUS, "-", null, @operator[3])
        end if

        if @expr[0] == "Variable" then
            _name = @expr
            assign = NewAssignExpr(@_name[1], NewBinaryExpr(@expr, assignOp, NewLiteralExpr(1)))

            return NewPostfixExpr(@_name, @operator, @assign)
        end if
        if @expr[0] == "Get" then
            get = @expr
            assign = NewSetExpr(@get[1], @get[2], NewBinaryExpr(NewGetExpr(@get[1], @get[2]), assignOp, NewLiteralExpr(1)))

            return NewPostfixExpr(@get, @operator, @assign)
        end if
        if @expr[0] == "Subscript" then
            subscript = @expr
            assign = NewSubscriptSetExpr(@subscript[1], @subscript[2], NewBinaryExpr(NewSubscriptExpr(@subscript[1], @subscript[2], @subscript[3]), assignOp, NewLiteralExpr(1)), @subscript[3])

            return NewPostfixExpr(@subscript, @operator, @assign)
        end if
    end if

    return @expr
end function
// @throwable
ParserFinishCall = function(parser, callee)
    arguments = []
    if not ParserCheck(@parser, @TokenType.RIGHT_PAREN) then
        // do-while
        if arguments.len >= 255 then
            ParserError(ParserPeek(@parser), "Cannot have more than 255 arguments.")
        end if
        expr = ParserExpression(@parser)
        if @expr isa @RuntimeException then return @expr
        arguments.push(expr)
        while ParserMatch(@parser, [@TokenType.COMMA])
            if arguments.len >= 255 then
                ParserError(ParserPeek(@parser), "Cannot have more than 255 arguments.")
            end if
            expr = ParserExpression(@parser)
            if @expr isa @RuntimeException then return @expr
            arguments.push(expr)
        end while
    end if

    paren = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after arguments.")
    if @paren isa @RuntimeException then return @paren

    return NewCallExpr(@callee, @paren, @arguments)
end function
// @throwable
ParserCall = function(parser)
    expr = ParserPrimary(@parser)
    if @expr isa @RuntimeException then return expr

    while true
        if ParserMatch(@parser, [@TokenType.LEFT_PAREN]) then
            expr = ParserFinishCall(@parser, @expr)
            if @expr isa @RuntimeException then return expr
        else if ParserMatch(@parser, [@TokenType.DOT]) then
            _name = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect property name after '.'.")
            if @_name isa @RuntimeException then return @_name
            expr = NewGetExpr(@expr, @_name)
        else if ParserMatch(@parser, [@TokenType.LEFT_SQUARE]) then
            // slice without start
            if ParserMatch(@parser, [@TokenType.COLON]) then
                // slice without end
                if ParserMatch(@parser, [@TokenType.RIGHT_SQUARE]) then
                    expr = NewSliceExpr(@expr, null, null, ParserPrevious(@parser))
                else
                    _end = ParserExpression(@parser)
                    if @_end isa @RuntimeException then return @_end
                    throw = ParserConsume(@parser, @TokenType.RIGHT_SQUARE, "Expect ']' after slice.")
                    if @throw isa @RuntimeException then return @throw
                    expr = NewSliceExpr(@expr, null, @_end, @throw)
                end if
            else
                index = ParserExpression(@parser)
                if @index isa @RuntimeException then return @index
                // slice
                if ParserMatch(@parser, [@TokenType.COLON]) then
                    // slice without end
                    if ParserMatch(@parser, [@TokenType.RIGHT_SQUARE]) then
                        expr = NewSliceExpr(@expr, @index, null, ParserPrevious(@parser))
                    else
                        _end = ParserExpression(@parser)
                        if @_end isa @RuntimeException then return @_end
                        throw = ParserConsume(@parser, @TokenType.RIGHT_SQUARE, "Expect ']' after slice.")
                        if @throw isa @RuntimeException then return @throw
                        expr = NewSliceExpr(@expr, @index, @_end, @throw)
                    end if
                else 
                    throw = ParserConsume(@parser, @TokenType.RIGHT_SQUARE, "Expect ']' after index.")
                    if @throw isa @RuntimeException then return @throw
                    expr = NewSubscriptExpr(@expr, @index, @throw)
                end if
            end if
        else
            break
        end if
    end while
    return @expr
end function
// @throwable
ParserPrimary = function(parser)
    if ParserMatch(@parser, [@TokenType.FALSE]) then return NewLiteralExpr(false)
    if ParserMatch(@parser, [@TokenType.TRUE]) then return NewLiteralExpr(true)
    if ParserMatch(@parser, [@TokenType.NIL]) then return NewLiteralExpr(null)
    
    if ParserMatch(@parser, [@TokenType.NUMBER, @TokenType.STRING]) then return NewLiteralExpr(ParserPrevious(@parser)[2])

    if ParserMatch(@parser, [@TokenType.SUPER]) then
        keyword = ParserPrevious(@parser)
        throw = ParserConsume(@parser, @TokenType.DOT, "Expect '.' after 'super'.")
        if @throw isa @RuntimeException then return throw
        method = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect superclass method name.")

        return NewSuperExpr(@keyword, @method)
    end if

    if ParserMatch(@parser, [@TokenType.THIS]) then return NewThisExpr(ParserPrevious(@parser))

    // lambda(){}
    if ParserMatch(@parser, [@TokenType.LAMBDA]) then
        _name = ParserPrevious(@parser)
        throw = ParserConsume(@parser, @TokenType.LEFT_PAREN, "Expect '(' after lambda.")
        if @throw isa @RuntimeException then return @throw

        parameters = []
        if not ParserCheck(@parser, @TokenType.RIGHT_PAREN) then
            // do-while
            if parameters.len >= 255 then
                ParserError(ParserPeek(@parser), "Cannot have more than 255 parameters.")
            end if
            throw = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect parameter name.")
            if @throw isa @RuntimeException then return @throw
            parameters.push(@throw)
            while ParserMatch(@parser, [@TokenType.COMMA])
                if parameters.len >= 255 then
                    ParserError(ParserPeek(@parser), "Cannot have more than 255 parameters.")
                end if
                throw = ParserConsume(@parser, @TokenType.IDENTIFIER, "Expect parameter name.")
                if @throw isa @RuntimeException then return @throw
                parameters.push(@throw)
            end while
        end if

        throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after lambda parameters.")
        if @throw isa @RuntimeException then return @throw

        throw = ParserConsume(@parser, @TokenType.LEFT_BRACE, "Expect '{' before lambda body.")
        if @throw isa @RuntimeException then return @throw

        body = ParserBlock(@parser)
        if @body isa @RuntimeException then return @body

        return NewLambdaExpr(@_name, @parameters, @body)
    end if


    if ParserMatch(@parser, [@TokenType.IDENTIFIER]) then return NewVariableExpr(ParserPrevious(@parser))

    if ParserMatch(@parser, [@TokenType.LEFT_PAREN]) then
        expr = ParserExpression(@parser)
        if @expr isa @RuntimeException then return expr
        throw = ParserConsume(@parser, @TokenType.RIGHT_PAREN, "Expect ')' after expression.")
        if @throw isa @RuntimeException then return throw
        return NewGroupingExpr(@expr)
    end if

    // parse list
    if ParserMatch(@parser, [@TokenType.LEFT_SQUARE]) then
        _values = []
        if not ParserCheck(@parser, @TokenType.RIGHT_SQUARE) then
            // do-while
            expr = ParserExpression(@parser)
            if @expr isa @RuntimeException then return @expr
            _values.push(@expr)
            while ParserMatch(@parser, [@TokenType.COMMA])
                // optional end ','
                if ParserCheck(@parser, @TokenType.RIGHT_SQUARE) then break

                expr = ParserExpression(@parser)
                if @expr isa @RuntimeException then return @expr
                _values.push(@expr)
            end while
        end if

        throw = ParserConsume(@parser, @TokenType.RIGHT_SQUARE, "Expect ']' after list.")
        if @throw isa @RuntimeException then return @throw
        return NewListExpr(@_values)
    end if

    // parse map
    if ParserMatch(@parser, [@TokenType.LEFT_BRACE]) then
        _values = {}
        if not ParserCheck(@parser, @TokenType.RIGHT_BRACE) then
            // do-while
            key = ParserExpression(@parser)
            if @key isa @RuntimeException then return @key
            throw = ParserConsume(@parser, @TokenType.COLON, "Expect ':' after map key.")
            if @throw isa @RuntimeException then return @throw
            value = ParserExpression(@parser)
            if @value isa @RuntimeException then return @value
            _values[@key] = @value
            while ParserMatch(@parser, [@TokenType.COMMA])
                // optional end ','
                if ParserCheck(@parser, @TokenType.RIGHT_BRACE) then break
                key = ParserExpression(@parser)
                if @key isa @RuntimeException then return @key
                throw = ParserConsume(@parser, @TokenType.COLON, "Expect ':' after map key.")
                if @throw isa @RuntimeException then return @throw
                value = ParserExpression(@parser)
                if @value isa @RuntimeException then return @value
                _values[@key] = @value
            end while
        end if

        throw = ParserConsume(@parser, @TokenType.RIGHT_BRACE, "Expect '}' after map.")
        if @throw isa @RuntimeException then return @throw
        return NewMapExpr(@_values)
    end if

    return ParserError(ParserPeek(@parser), "Expect expression.")
end function
ParserMatch = function(parser, types)
    for type in @types
        if ParserCheck(@parser, @type) then
            ParserAdvance(@parser)
            return true
        end if
    end for
    return false
end function
// @throwable
ParserConsume = function(parser, type, message)
    if ParserCheck(@parser, @type) then return ParserAdvance(@parser)
    return ParserError(ParserPeek(@parser), @message)
end function
ParserCheck = function(parser, type)
    if ParserIsAtEnd(@parser) then return false
    return ParserPeek(@parser)[0] == @type
end function
ParserAdvance = function(parser)
    if not ParserIsAtEnd(@parser) then @parser[1] = @parser[1] + 1
    return ParserPrevious(@parser)
end function
ParserIsAtEnd = function(parser)
    return ParserPeek(@parser)[0] == @TokenType.EOF
end function
ParserPeek = function(parser)
    return @parser[0][@parser[1]]
end function
ParserPrevious = function(parser)
    return @parser[0][@parser[1] - 1]
end function
ParserError = function(token, message)
    LoxErrorTM(@token, @message)
    return NewParseError()
end function
ParserSynchronize = function(parser)
    ParserAdvance(@parser)
    while not ParserIsAtEnd(@parser)
        if ParserPrevious(@parser)[0] == @TokenType.SEMICOLON then return
        peekType = ParserPeek(@parser)[0]
        if peekType == @TokenType.CLASS or peekType == @TokenType.FUN or peekType == @TokenType.VAR or
        peekType == @TokenType.FOR or peekType == @TokenType.IF or peekType == @TokenType.WHILE or
        peekType == @TokenType.PRINT or peekType == @TokenType.RETURN then return
        ParserAdvance(@parser)
    end while
end function
// stmt
// @throwable
StmtAccept = function(stmt, visitor)
    if @stmt[0] == "Block" then return VisitorVisitBlockStmt(@visitor, @stmt)
    if @stmt[0] == "Class" then return VisitorVisitClassStmt(@visitor, @stmt)
    if @stmt[0] == "Expression" then return VisitorVisitExpressionStmt(@visitor, @stmt)
    if @stmt[0] == "Function" then return VisitorVisitFunctionStmt(@visitor, @stmt)
    if @stmt[0] == "If" then return VisitorVisitIfStmt(@visitor, @stmt)
    if @stmt[0] == "Switch" then return VisitorVisitSwitchStmt(@visitor, @stmt)
    if @stmt[0] == "Try" then return VisitorVisitTryStmt(@visitor, @stmt)
    if @stmt[0] == "Throw" then return VisitorVisitThrowStmt(@visitor, @stmt)
    if @stmt[0] == "Print" then return VisitorVisitPrintStmt(@visitor, @stmt)
    if @stmt[0] == "Return" then return VisitorVisitReturnStmt(@visitor, @stmt)
    if @stmt[0] == "Break" then return VisitorVisitBreakStmt(@visitor, @stmt)
    if @stmt[0] == "Continue" then return VisitorVisitContinueStmt(@visitor, @stmt)
    if @stmt[0] == "Var" then return VisitorVisitVarStmt(@visitor, @stmt)
    if @stmt[0] == "Foreach" then return VisitorVisitForeachStmt(@visitor, @stmt)
    if @stmt[0] == "DoWhile" then return VisitorVisitDoWhileStmt(@visitor, @stmt)
    if @stmt[0] == "While" then return VisitorVisitWhileStmt(@visitor, @stmt)
end function
// block
// @statements  stmt[1] Stmt[]
NewBlockStmt = function(statements)
    return ["Block", @statements, rnd]
end function
// class
// @name        stmt[1] Token
// @superclass  stmt[2] Expr
// @methods     stmt[3] Stmt[]
NewClassStmt = function(_name, superclass, methods)
    return ["Class", @_name, @superclass, @methods, rnd]
end function
// expression
// @expression  stmt[1] Expr
NewExpressionStmt = function(expression)
    return ["Expression", @expression, rnd]
end function
// function
// @name        stmt[1] Token
// @params  stmt[2] Token[]
// @body        stmt[3] Stmt[]
NewFunctionStmt = function(_name, _params, body)
    return ["Function", @_name, @_params, @body, rnd]
end function
// switch
// @value       stmt[1] Expr
// @conditions  stmt[2] Expr[]
// @bodies      stmt[3] Stmt[][]
// @default     stmt[4] Stmt[]
NewSwitchStmt = function(value, conditions, bodies, default)
    return ["Switch", @value, @conditions, @bodies, @default, rnd]
end function
// try
// @tryBody     stmt[1] NewBlockStmt
// @catchValue  stmt[2] Token
// @catchBody   stmt[3] NewBlockStmt
// @finallyBody stmt[4] NewBlockStmt
NewTryStmt = function(tryBody, catchValue, catchBody, finallyBody)
    return ["Try", @tryBody, @catchValue, @catchBody, @finallyBody, rnd]
end function
// throw
// @value       stmt[1] Expr
NewThrowStmt = function(value)
    return ["Throw", @value, rnd]
end function
// if
// @condition   stmt[1] Expr
// @thenBranch  stmt[2] Stmt
// @elseBranch  stmt[3] Stmt
NewIfStmt = function(condition, thenBranch, elseBranch)
    return ["If", @condition, @thenBranch, @elseBranch, rnd]
end function
// print
// @expression  stmt[1] Expr
NewPrintStmt = function(expression)
    return ["Print", @expression, rnd]
end function
// return
// @keyword     stmt[1] Token
// @value       stmt[2] Expr
// @isTailCall  stmt[3] Boolean
NewReturnStmt = function(keyword, value, isTailCall)
    return ["Return", @keyword, @value, isTailCall, rnd]
end function
// break
// @keyword     stmt[1] Token
NewBreakStmt = function(keyword)
    return ["Break", @keyword, rnd]
end function
// continue
// @keyword     stmt[1] Token
NewContinueStmt = function(keyword)
    return ["Continue", @keyword, rnd]
end function
// var
// @name        stmt[1] Token
// @initializer stmt[2] Expr
NewVarStmt = function(_name, initializer)
    return ["Var", @_name, @initializer, rnd]
end function
// foreach
// @name        stmt[1] Token
// @iterable    stmt[2] Expr
// @body        stmt[3] Stmt
NewForeachStmt = function(_name, iterable, body)
    return ["Foreach", @_name, @iterable, @body, rnd]
end function
// do-while
// @condition   stmt[1] Expr
// @body        stmt[2] Stmt
NewDoWhileStmt = function(condition, body)
    return ["DoWhile", @condition, @body, rnd]
end function
// while
// @condition   stmt[1] Expr
// @body        stmt[2] Stmt
NewWhileStmt = function(condition, body)
    return ["While", @condition, @body, rnd]
end function
// visitor
// @throwable
VisitorVisitBlockStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitBlockStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitBlockStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitClassStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitClassStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitClassStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitExpressionStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitExpressionStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitExpressionStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitFunctionStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitFunctionStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitFunctionStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitIfStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitIfStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitIfStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitSwitchStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitSwitchStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitSwitchStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitTryStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitTryStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitTryStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitThrowStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitThrowStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitThrowStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitPrintStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitPrintStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitPrintStmt(@visitor, @stmt)
    end if
end function
// @throwable
IntrpVisitContinueStmt = function(intrp, stmt)
    if not @intrp[3] then
        return NewRuntimeError(@stmt[1], "Cannot continue outside of a loop.")
    end if
    return NewContinue()
end function
// @throwable
IntrpVisitBreakStmt = function(intrp, stmt)
    if not @intrp[3] and not @intrp[4] then
        return NewRuntimeError(@stmt[1], "Cannot break outside of a loop or switch.")
    end if
    return NewBreak()
end function
// @throwable
VisitorVisitReturnStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitReturnStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitReturnStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitBreakStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitBreakStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitBreakStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitContinueStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitContinueStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitContinueStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitVarStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitVarStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitVarStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitForeachStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitForeachStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitForeachStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitDoWhileStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitDoWhileStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitDoWhileStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitWhileStmt = function(visitor, stmt)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitWhileStmt(@visitor, @stmt)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitWhileStmt(@visitor, @stmt)
    end if
end function
// @throwable
VisitorVisitAssignExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitAssignExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitAssignExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitBinaryExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitBinaryExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitBinaryExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitTenaryExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitTenaryExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitTenaryExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitCallExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitCallExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitCallExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitGetExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitGetExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitGetExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitSubscriptExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitSubscriptExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitSubscriptExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitSliceExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitSliceExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitSliceExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitGroupingExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitGroupingExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitGroupingExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitLiteralExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitLiteralExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitLiteralExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitLambdaExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitLambdaExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitLambdaExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitListExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitListExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitListExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitMapExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitMapExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitMapExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitLogicalExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitLogicalExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitLogicalExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitSetExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitSetExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitSetExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitSubscriptSetExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitSubscriptSetExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitSubscriptSetExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitSuperExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitSuperExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitSuperExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitThisExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitThisExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitThisExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitUnaryExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitUnaryExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitUnaryExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitPrefixExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitPrefixExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitPrefixExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitPostfixExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitPostfixExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitPostfixExpr(@visitor, @expr)
    end if
end function
// @throwable
VisitorVisitVariableExpr = function(visitor, expr)
    if @visitor[-1] == "Interpreter" then
        return IntrpVisitVariableExpr(@visitor, @expr)
    else if @visitor[-1] == "Resolver" then
        return ResolverVisitVariableExpr(@visitor, @expr)
    end if
end function
// resolver
FunctionType = {
    "NONE": "NONE",
    "FUNCTION": "FUNCTION",
    "INITIALIZER": "INITIALIZER",
    "METHOD": "METHOD",
}
ClassType = {
    "NONE": "NONE",
    "CLASS": "CLASS",
    "SUBCLASS": "SUBCLASS",
}
// @interpreter     resolver[0]
// @scopes          resolver[1]     string[]
// @currentFunction resolver[2]     FunctionType
// @currentClass    resolver[3]     ClassType
NewResolver = function(interpreter)
    return [interpreter, [], @FunctionType.NONE, @ClassType.NONE, "Resolver"]
end function
// @throwable
ResolverResolve = function(resolver, statements)
    for statement in @statements
        throw = ResolverResolveStmt(@resolver, @statement)
        if @throw isa @RuntimeException then return @throw
    end for
end function
// @throwable
ResolverVisitBlockStmt = function(resolver, stmt)
    ResolverBeginScope(@resolver)
    throw = ResolverResolve(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw
    ResolverEndScope(@resolver)
end function
// @throwable
ResolverVisitClassStmt = function(resolver, stmt)
    enclosingClass = @resolver[3]
    resolver[3] = @ClassType.CLASS

    ResolverDeclare(@resolver, @stmt[1])
    ResolverDefine(@resolver, @stmt[1])

    if @stmt[2] != null and @stmt[1][1] == @stmt[2][1] then
        LoxErrorTM(@stmt[2][1], "A class cannot inherit from itself.")
    end if

    if @stmt[2] != null then
        @resolver[3] = @ClassType.SUBCLASS
        throw = ResolverResolve(@resolver, @stmt[2])
        if @throw isa @RuntimeException then return @throw
    end if

    if @stmt[2] != null then
        ResolverBeginScope(@resolver)
        @resolver[1][resolver[1].len - 1]["super"] = true
    end if

    ResolverBeginScope(@resolver)
    @resolver[1][resolver[1].len - 1]["this"] = true

    for method in @stmt[3]
        declaration = @FunctionType.METHOD
        if @method[1][1] == "init" then
            declaration = @FunctionType.INITIALIZER
        end if
        throw = ResolverResolveFunction(@resolver, @method, @declaration)
        if @throw isa @RuntimeException then return @throw
    end for

    ResolverEndScope(@resolver)

    if @stmt[2] != null then ResolverEndScope(@resolver)

    resolver[3] = @enclosingClass
end function
// @throwable
ResolverVisitExpressionStmt = function(resolver, stmt)
    throw = ResolverResolveExpr(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitFunctionStmt = function(resolver, stmt)
    ResolverDeclare(@resolver, @stmt[1])
    ResolverDefine(@resolver, @stmt[1])
    throw = ResolverResolveFunction(@resolver, @stmt, @FunctionType.FUNCTION)
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitIfStmt = function(resolver, stmt)
    throw = ResolverResolveExpr(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveStmt(@resolver, @stmt[2])
    if @throw isa @RuntimeException then return @throw
    if @stmt[3] != null then
        throw = ResolverResolveStmt(@resolver, @stmt[3])
        if @throw isa @RuntimeException then return @throw
    end if
end function
// @throwable
ResolverVisitSwitchStmt = function(resolver, stmt)
    throw = ResolverResolveExpr(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw

    for i in range(0, stmt[2].len-1, 1)
        throw = ResolverResolveExpr(@resolver, @stmt[2][i])
        if @throw isa @RuntimeException then return @throw

        ResolverBeginScope(@resolver)

        for statement in @stmt[3][i]
            throw = ResolverResolveStmt(@resolver, @statement)
            if @throw isa @RuntimeException then return @throw
        end for
        
        ResolverEndScope(@resolver)
    end for
    
    if @stmt[4] != null then
        ResolverBeginScope(@resolver)

        for statement in @stmt[4]
            throw = ResolverResolveStmt(@resolver, @statement)
            if @throw isa @RuntimeException then return @throw
        end for

        ResolverEndScope(@resolver)
    end if
end function
// @throwable
ResolverVisitTryStmt = function(resolver, stmt)
    throw = ResolverResolve(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw

    if @stmt[3] != null then
        ResolverBeginScope(@resolver)
        if @stmt[2] != null then
            ResolverDeclare(@resolver, @stmt[2])
            ResolverDefine(@resolver, @stmt[2])
        end if

        for statement in @stmt[3][1]
            throw = ResolverResolveStmt(@resolver, @statement)
            if @throw isa @RuntimeException then return @throw
        end for

        ResolverEndScope(@resolver)
    end if

    if @stmt[4] != null then
        throw = ResolverResolve(@resolver, @stmt[4])
        if @throw isa @RuntimeException then return @throw
    end if
end function
// @throwable
ResolverVisitThrowStmt = function(resolver, stmt)
    throw = ResolverResolveExpr(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitPrintStmt = function(resolver, stmt)
    throw = ResolverResolveExpr(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitReturnStmt = function(resolver, stmt)
    if @resolver[2] == @FunctionType.NONE then
        LoxErrorTM(@stmt[1], "Cannot return from top-level code.")
    end if

    if @stmt[2] != null then
        if @resolver[2] == @FunctionType.INITIALIZER then
            LoxErrorTM(@stmt[1], "Cannot return a value from an initializer.")
        end if
        throw = ResolverResolveExpr(@resolver, @stmt[2])
        if @throw isa @RuntimeException then return @throw
    end if
end function
// @throwable
ResolverVisitBreakStmt = function(resolver, stmt)
    // do nothing
end function
// @throwable
ResolverVisitContinueStmt = function(resolver, stmt)
    // do nothing
end function
// @throwable
ResolverVisitVarStmt = function(resolver, stmt)
    ResolverDeclare(@resolver, @stmt[1])
    if @stmt[2] != null then
        throw = ResolverResolveExpr(@resolver, @stmt[2])
        if @throw isa @RuntimeException then return @throw
    end if
    ResolverDefine(@resolver, @stmt[1])
end function
// @throwable
ResolverVisitForeachStmt = function(resolver, stmt)
    throw = ResolverResolveExpr(@resolver, @stmt[2])
    if @throw isa @RuntimeException then return @throw
    ResolverBeginScope(@resolver)
    ResolverDeclare(@resolver, @stmt[1])
    ResolverDefine(@resolver, @stmt[1])
    throw = ResolverResolveStmt(@resolver, @stmt[3])
    if @throw isa @RuntimeException then return @throw
    ResolverEndScope(@resolver)
end function
// @throwable
ResolverVisitDoWhileStmt = function(resolver, stmt)
    throw = ResolverResolveStmt(@resolver, @stmt[2])
    if @throw isa @RuntimeException then return @throw

    throw = ResolverResolveExpr(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitWhileStmt = function(resolver, stmt)
    throw = ResolverResolveExpr(@resolver, @stmt[1])
    if @throw isa @RuntimeException then return @throw
    
    throw = ResolverResolveStmt(@resolver, @stmt[2])
    if @throw isa @RuntimeException then return @throw
end function
// expr
// @throwable
ResolverVisitAssignExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[2])
    if @throw isa @RuntimeException then return @throw
    ResolverResolveLocal(@resolver, @expr, @expr[1])
end function
// @throwable
ResolverVisitBinaryExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
    ResolverResolveExpr(@resolver, @expr[3])
end function
// @throwable
ResolverVisitTenaryExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveExpr(@resolver, @expr[2])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveExpr(@resolver, @expr[3])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitCallExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
    for argument in @expr[3]
        throw = ResolverResolveExpr(@resolver, @argument)
        if @throw isa @RuntimeException then return @throw
    end for
end function
// @throwable
ResolverVisitGetExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitSubscriptExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveExpr(@resolver, @expr[2])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitSliceExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
    if @expr[2] != null then
        throw = ResolverResolveExpr(@resolver, @expr[2])
        if @throw isa @RuntimeException then return @throw
    end if
    if @expr[3] != null then
        throw = ResolverResolveExpr(@resolver, @expr[3])
        if @throw isa @RuntimeException then return @throw
    end if
end function
// @throwable
ResolverVisitGroupingExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
end function
ResolverVisitLiteralExpr = function(resolver, expr)
    // do nothing
end function
// @throwable
ResolverVisitLambdaExpr = function(resolver, expr)
    ResolverResolveFunction(@resolver, @expr, @FunctionType.FUNCTION)
end function
// @throwable
ResolverVisitListExpr = function(resolver, expr)
    for value in @expr[1]
        throw = ResolverResolveExpr(@resolver, @value)
        if @throw isa @RuntimeException then return @throw
    end for
end function
// @throwable
ResolverVisitMapExpr = function(resolver, expr)
    for key in @expr[1].indexes
        throw = ResolverResolveExpr(@resolver, @key)
        if @throw isa @RuntimeException then return @throw
        throw = ResolverResolveExpr(@resolver, @expr[1][@key])
        if @throw isa @RuntimeException then return @throw
    end for
end function
// @throwable
ResolverVisitLogicalExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveExpr(@resolver, @expr[3])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitSetExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[3])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitSubscriptSetExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[3])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw
    throw = ResolverResolveExpr(@resolver, @expr[2])
    if @throw isa @RuntimeException then return @throw
end function
ResolverVisitSuperExpr = function(resolver, expr)
    if @resolver[3] == @ClassType.NONE then
        LoxErrorTM(@expr[1], "Cannot use 'super' outside of a class.")
    else if @resolver[3] != @ClassType.SUBCLASS then
        LoxErrorTM(@expr[1], "Cannot use 'super' in a class with no superclass.")
    end if

    ResolverResolveLocal(@resolver, @expr, @expr[1])
end function
ResolverVisitThisExpr = function(resolver, expr)
    if @resolver[3] == @ClassType.NONE then
        LoxErrorTM(@expr[1], "Cannot use 'this' outside of a class.")
        return
    end if
    ResolverResolveLocal(@resolver, @expr, @expr[1])
end function
// @throwable
ResolverVisitUnaryExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[2])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitPrefixExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw

    throw = ResolverResolveStmt(@resolver, @expr[3])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverVisitPostfixExpr = function(resolver, expr)
    throw = ResolverResolveExpr(@resolver, @expr[1])
    if @throw isa @RuntimeException then return @throw

    throw = ResolverResolveStmt(@resolver, @expr[3])
    if @throw isa @RuntimeException then return @throw
end function
ResolverVisitVariableExpr = function(resolver, expr)
    if resolver[1].len != 0 and (resolver[1][resolver[1].len - 1].hasIndex(@expr[1][1]) and resolver[1][resolver[1].len - 1][@expr[1][1]] == false) then
        LoxErrorTM(@expr[1], "Cannot read local variable in its own initializer.")
    end if

    ResolverResolveLocal(@resolver, @expr, @expr[1])
end function
// @throwable
ResolverResolveStmt = function(resolver, stmt)
    throw = StmtAccept(@stmt, @resolver)
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverResolveExpr = function(resolver, expr)
    throw = ExprAccept(@expr, @resolver)
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
ResolverResolveFunction = function(resolver, _function, type)
    enclosingFunction = @resolver[2]
    @resolver[2] = @type
    ResolverBeginScope(@resolver)
    for param in @_function[2]
        ResolverDeclare(@resolver, @param)
        ResolverDefine(@resolver, @param)
    end for
    throw = ResolverResolve(@resolver, @_function[3])
    if @throw isa @RuntimeException then return @throw
    ResolverEndScope(@resolver)
    @resolver[2] = @enclosingFunction
end function
ResolverBeginScope = function(resolver)
    @resolver[1].push({})
end function
ResolverEndScope = function(resolver)
    @resolver[1].pop()
end function
ResolverDeclare = function(resolver, _name)
    if resolver[1].len == 0 then return
    scope = @resolver[1][resolver[1].len - 1]
    if scope.hasIndex(@_name[1]) then
        LoxErrorTM(@_name, "Already a variable with this name in this scope.")
    end if

    scope[@_name[1]] = false
end function
ResolverDefine = function(resolver, _name)
    if resolver[1].len == 0 then return
    @resolver[1][resolver[1].len - 1][@_name[1]] = true
end function
ResolverResolveLocal = function(resolver, expr, _name)
    for i in range(resolver[1].len - 1, 0, -1)
        if resolver[1][@i].hasIndex(@_name[1]) then
            IntrpResolve(@resolver[0], @expr, resolver[1].len - 1 - @i)
            return
        end if
    end for
end function
// environment
// @enclosing  env[0] Environment
// @values     env[1] string: Object
NewEnvironment = function(enclosing=null)
    return [enclosing, {}]
end function
// @throwable
EnvironmentGet = function(env, _name)
    if env[1].hasIndex(@_name[1]) then
        return @env[1][@_name[1]]
    end if

    if @env[0] != null then
        return EnvironmentGet(@env[0], @_name)
    end if

    return NewRuntimeError(@_name, "Undefined variable '" + @_name[1] + "'.")
end function
// @throwable
EnvironmentAssign = function(env, _name, value)
    if env[1].hasIndex(@_name[1]) then
        @env[1][@_name[1]] = @value
        return
    end if

    if @env[0] != null then
        throw = EnvironmentAssign(@env[0], @_name, @value)
        if @throw isa @RuntimeException then return @throw
        return
    end if

    return NewRuntimeError(@_name, "Undefined variable '" + @_name[1] + "'.")
end function
EnvironmentDefine = function(env, _name, value)
    @env[1][@_name] = @value
end function
EnvironmentAncestor = function(env, distance)
    ancestor = @env
    for i in range(0, @distance - 1, 1)
        ancestor = @ancestor[0]
    end for
    return @ancestor
end function
EnvironmentGetAt = function(env, distance, _name)
    ancestor = EnvironmentAncestor(@env, @distance)[1]
    if ancestor.hasIndex(@_name) then
        return @ancestor[@_name]
    end if
    return null
end function
EnvironmentAssignAt = function(env, distance, _name, value)
    EnvironmentAncestor(@env, @distance)[1][@_name[1]] = @value
end function
EnvironmentTostring = function(env)
    result = str(@env[1])
    if @env[0] != null then
        result = @result + " -> " + EnvironmentTostring(@env[0])
    end if

    return @result
end function
// lox callable
IsLoxCallable = function(callable)
    return @callable isa funcRef or @callable[0] == "LoxFunction" or @callable[0] == "LoxClass" or Intrinsics.hasIndex(@callable[0]) or @callable[0] == "StrIntr" or @callable[0] == "ListIntr" or @callable[0] == "MapIntr"
end function
LoxCallableToString = function(callable)
    if @callable[0] == "LoxFunction" then
        return "<fn " + @callable[1][1] + ">"
    end if
    if @callable[0] == "LoxClass" then
        return @callable[1]
    end if
    if Intrinsics.hasIndex(@callable[0]) then
        return "<native fn>"
    end if
end function
LoxCallableArity = function(callable)
    if @callable[0] == "LoxFunction" then
        return callable[1][2].len
    end if
    if @callable[0] == "LoxClass" then
        initializer = LoxClassFindMethod(@callable, "init")
        if @initializer == null then return 0
        return LoxCallableArity(@initializer)
    end if
    if @callable[0] == "StrIntr" then
        return @callable[1]
    end if
    if @callable[0] == "ListIntr" then
        return @callable[1]
    end if
    if @callable[0] == "MapIntr" then
        return @callable[1]
    end if
    if  Intrinsics.hasIndex(@callable[0]) then
        // return Intrinsics[@callable[0]][1](@callable)
        return Intrinsics[@callable[0]][1]
    end if
end function
// @catchable
// @throwable
LoxCallableCall = function(callable, intrp, arguments)
    preIsInLoop = @intrp[3]
    intrp[3] = false

    preIsInSwitch = @intrp[4]
    intrp[4] = false

    if @callable[0] == "LoxFunction" then
        environment = NewEnvironment(@callable[2])
        for i in range(0, callable[1][2].len - 1, 1)
            EnvironmentDefine(@environment, @callable[1][2][@i][1], @arguments[@i])
        end for
        
        throw = IntrpExecuteBlock(@intrp, @callable[1][3], @environment)

        intrp[3] = @preIsInLoop
        intrp[4] = @preIsInSwitch

        if @throw isa @Return then
            if @callable[3] then return EnvironmentGetAt(@callable[2], 0, "this")
            return @throw.value
        end if
        if @throw isa @RuntimeException then return @throw

        if @callable[3] then return EnvironmentGetAt(@callable[2], 0, "this")
        return null
    end if
    if @callable[0] == "LoxClass" then
        instance = NewLoxInstance(@callable)
        initializer = LoxClassFindMethod(@callable, "init")
        if @initializer != null then
            bind = LoxFunctionBind(@initializer, @instance)
            throw = LoxCallableCall(@bind, @intrp, @arguments)
            if @throw isa @RuntimeException then 
                intrp[3] = @preIsInLoop
                intrp[4] = @preIsInSwitch
                return @throw
            end if
        end if
        intrp[3] = @preIsInLoop
        intrp[4] = @preIsInSwitch
        return @instance
    end if
    if @callable[0] == "StrIntr" then
        ret = @callable[2]
        return ret(@callable[-1], @intrp, @arguments)
    end if
    if Intrinsics.hasIndex(@callable[0]) then
        intrinsicFn = @Intrinsics[@callable[0]][2]
        intrp[3] = @preIsInLoop
        intrp[4] = @preIsInSwitch
        return intrinsicFn(@intrp, @arguments)
    end if
end function
// lox function
// @declaration     function[1] FunctionStmt
// @closure         function[2] Environment
// @isInitializer   function[3] boolean
NewLoxFunction = function(declaration, closure, isInitializer)
    return ["LoxFunction", @declaration, @closure, @isInitializer]
end function
LoxFunctionBind = function(fn, instance)
    environment = NewEnvironment(@fn[2])
    EnvironmentDefine(@environment, "this", @instance)
    return NewLoxFunction(@fn[1], @environment, @fn[3])
end function
// lox class
// @name        class[1] string
// @superclass  class[2] LoxClass
// @methods     class[3] string: LoxFunction
NewLoxClass = function(_name, superclass, methods)
    return ["LoxClass", @_name, @superclass, @methods]
end function
LoxClassFindMethod = function(loxClass, _name)
    if @loxClass[3].hasIndex(@_name) then
        return @loxClass[3][@_name]
    end if

    if @loxClass[2] != null then
        return LoxClassFindMethod(@loxClass[2], @_name)
    end if
end function
// lox instance
// @klass  instance[1] LoxClass
// @fields instance[2] string: Object
NewLoxInstance = function(klass)
    return ["LoxInstance", @klass, {}, rnd]
end function
// @throwable
LoxInstanceGet = function(instance, _name)
    if @instance[2].hasIndex(@_name[1]) then
        return @instance[2][@_name[1]]
    end if
    method = LoxClassFindMethod(@instance[1], @_name[1])
    if @method != null then return LoxFunctionBind(@method, @instance)

    return @NewRuntimeError(@_name, "Undefined property '" + @_name[1] + "'.")
end function
LoxInstanceSet = function(instance, _name, value)
    @instance[2][@_name[1]] = @value
end function
LoxInstanceToString = function(instance)
    return @instance[1][1] + " instance"
end function
// lox list
// @values list[1] Object[]
NewLoxList = function(_values, _rnd=null)
    if @_rnd == null then return ["LoxList", @_values, rnd]
    return ["LoxList", @_values, _rnd]
end function
// @throwable
LoxListInbounds = function(_list, index, _name)
    if @index < 0 then @index = _list[1].len + @index
    if @index < 0 or @index >= _list[1].len then
        return NewRuntimeError(@_name, "Index " + @index + " out of bounds.")
    end if
end function
// @throwable
LoxListSet = function(_list, index, value, _name)
    if @index < 0 then @index = _list[1].len + @index

    throw = LoxListInbounds(@_list, @index, @_name)
    if @throw isa @RuntimeException then return @throw

    _list[1][@index] = @value  
end function
// @throwable
LoxListGet = function(_list, index, _name)
    if @index < 0 then index = _list[1].len + @index

    throw = LoxListInbounds(@_list, @index, @_name)
    if @throw isa @RuntimeException then return @throw

    return @_list[1][@index]
end function
// lox map
// @values map[1] string: Object
NewLoxMap = function(_values)
    return ["LoxMap", @_values, rnd]
end function
LoxMapSet = function(_map, key, value)
    _map[1][@key] = @value
end function
// @throwable
LoxMapGet = function(_map, key, _name)
    if _map[1].hasIndex(@key) then
        return @_map[1][@key]
    end if

    return NewRuntimeError(@_name, "Key " + @key + " not found in map.")
end function
// intrinsics
StrIntrs = {}
// NOTE: _str will be dynamically pushed to the end of list (the same for list and map)
AddStrIntrs = function(_name, arity, callable, isProperty=null)
    if @isProperty == null then isProperty = false
    StrIntrs[@_name] = ["StrIntr", @arity, @callable, @isProperty]
end function
strLen = function(_str, intrp, arguments)
    return _str.len
end function
AddStrIntrs("len", null, @strLen, true)
strUpper = function(_str, intrp, arguments)
    return _str.upper
end function
AddStrIntrs("upper", 0, @strUpper)
strLower = function(_str, intrp, arguments)
    return _str.lower
end function
AddStrIntrs("lower", 0, @strLower)
strTrim = function(_str, intrp, arguments)
    return _str.trim
end function
AddStrIntrs("trim", 0, @strTrim)
strIndexOf = function(_str, intrp, arguments)
    return _str.indexOf(@arguments[0])
end function
AddStrIntrs("indexOf", 1, @strIndexOf)
strReplace = function(_str, intrp, arguments)
    return _str.replace(@arguments[0], @arguments[1])
end function
AddStrIntrs("replace", 2, @strReplace)
strSplit = function(_str, intrp, arguments)
    return _str.split(@arguments[0])
end function
ListIntrs = {}
// See AddStrIntrs
AddListIntrs = function(_name, arity, callable, isProperty=null)
    if @isProperty == null then isProperty = false
    ListIntrs[@_name] = ["ListIntr", @arity, @callable, @isProperty]
end function
listPush = function(_list, intrp, arguments)
    _list[1].push(@arguments[0])
end function
AddListIntrs("push", 1, @listPush)
listRemove = function(_list, intrp, arguments)
    _list[1].remove(@arguments[0])
end function
AddListIntrs("remove", 1, @listRemove)
listHasIndex = function(_list, intrp, arguments)
    return _list[1].hasIndex(@arguments[0])
end function
AddListIntrs("hasIndex", 1, @listHasIndex)
listSort = function(_list, intrp, arguments)
    _list[1].sort()
end function
AddListIntrs("sort", 0, @listSort)
listLen = function(_list, intrp, arguments)
    return _list[1].len
end function
AddListIntrs("len", null, @listLen, true)
// see AddStrIntrs
MapIntrs = {}
AddMapIntrs = function(_name, arity, callable, isProperty=null)
    if @isProperty == null then isProperty = false
    MapIntrs[@_name] = ["MapIntr", @arity, @callable, @isProperty]
end function
mapRemove = function(_map, intrp, arguments)
    _map[1].remove(@arguments[0])
end function
AddMapIntrs("remove", 1, @mapRemove)
mapHasIndex = function(_map, intrp, arguments)
    return _map[1].hasIndex(@arguments[0])
end function
AddMapIntrs("hasIndex", 1, @mapHasIndex)
mapLen = function(_map, intrp, arguments)
    return _map[1].len
end function
AddMapIntrs("len", null, @mapLen, true)
// { "xxx": ["xxx", arity, @callable] }
// @arity    intrinsics[1] number
// @callable intrinsics[2] callable
Intrinsics = {}
// Add an intrinsic function
// name: function name
// arity: number of arguments
// callable: function to call
AddIntrinsic = function(_name, arity, callable)
    Intrinsics[@_name] = [@_name, @arity, @callable]
end function
clockIntrinsic = function(intrp, arguments)
    return time
end function
AddIntrinsic("clock", 0, @clockIntrinsic)
absIntrinsic = function(intrp, arguments)
    return abs(@arguments[0])
end function
AddIntrinsic("abs", 1, @absIntrinsic)
acosIntrinsic = function(intrp, arguments)
    return acos(@arguments[0])
end function
AddIntrinsic("acos", 1, @acosIntrinsic)
asinIntrinsic = function(intrp, arguments)
    return asin(@arguments[0])
end function
AddIntrinsic("asin", 1, @asinIntrinsic)
atanIntrinsic = function(intrp, arguments)
    return atan(@arguments[0])
end function
AddIntrinsic("atan", 1, @atanIntrinsic)
bitAndIntrinsic = function(intrp, arguments)
    return bitAnd(@arguments[0], @arguments[1])
end function
AddIntrinsic("bitAnd", 2, @bitAndIntrinsic)
bitOrIntrinsic = function(intrp, arguments)
    return bitOr(@arguments[0], @arguments[1])
end function
AddIntrinsic("bitOr", 2, @bitOrIntrinsic)
bitXorIntrinsic = function(intrp, arguments)
    return bitXor(@arguments[0], @arguments[1])
end function
AddIntrinsic("bitXor", 2, @bitXorIntrinsic)
ceilIntrinsic = function(intrp, arguments)
    return ceil(@arguments[0])
end function
AddIntrinsic("ceil", 1, @ceilIntrinsic)
charIntrinsic = function(intrp, arguments)
    return char(@arguments[0])
end function
AddIntrinsic("char", 1, @charIntrinsic)
cosIntrinsic = function(intrp, arguments)
    return cos(@arguments[0])
end function
AddIntrinsic("cos", 1, @cosIntrinsic)
floorIntrinsic = function(intrp, arguments)
    return floor(@arguments[0])
end function
AddIntrinsic("floor", 1, @floorIntrinsic)
logIntrinsic = function(intrp, arguments)
    return log(@arguments[0], @arguments[1])
end function
AddIntrinsic("log", 2, @logIntrinsic)
rangeIntrinsic = function(intrp, arguments)
    return range(@arguments[0], @arguments[1], @arguments[2])
end function
AddIntrinsic("range", 3, @rangeIntrinsic)
roundIntrinsic = function(intrp, arguments)
    return round(@arguments[0])
end function
AddIntrinsic("round", 1, @roundIntrinsic)
rndIntrinsic = function(intrp, arguments)
    return rnd(@arguments[0])
end function
AddIntrinsic("rnd", 1, @rndIntrinsic)
signIntrinsic = function(intrp, arguments)
    return sign(@arguments[0])
end function
AddIntrinsic("sign", 1, @signIntrinsic)
sinIntrinsic = function(intrp, arguments)
    return sin(@arguments[0])
end function
AddIntrinsic("sin", 1, @sinIntrinsic)
sqrtIntrinsic = function(intrp, arguments)
    return sqrt(@arguments[0])
end function
AddIntrinsic("sqrt", 1, @sqrtIntrinsic)
strIntrinsic = function(intrp, arguments)
    return str(@arguments[0])
end function
AddIntrinsic("str", 1, @strIntrinsic)
tanIntrinsic = function(intrp, arguments)
    return tan(@arguments[0])
end function
AddIntrinsic("tan", 1, @tanIntrinsic)
// interpreter
// ClockFn = ["ClockFn"]
// @globals     intrp[0] Environment
// @environment intrp[1] Environment
// @locals      intrp[2] string: {}
// @isInLoop    intrp[3] boolean
// @isInSwitch  intrp[4] boolean
NewInterpreter = function
    _globals = NewEnvironment()
    environment =  @_globals
    _locals = {}
    for intrinsicName in Intrinsics.indexes
        EnvironmentDefine(@_globals, @intrinsicName, @Intrinsics[@intrinsicName])
    end for
    EnvironmentDefine(@_globals, "pi", pi)
    // EnvironmentDefine(@_globals, "clock", @ClockFn)
    return [_globals, @environment, @_locals, false, false, "Interpreter"]
end function
// @catchable
Interpret = function(intrp, statements)
    for statement in @statements
        throw = IntrpExecute(@intrp, @statement)
        if @throw isa @RuntimeError then
            LoxRuntimeError(@throw)
            return
        end if
    end for
end function
// @throwable
IntrpEvaluate = function(intrp, expr)
    return ExprAccept(@expr, @intrp)
end function
// @throwable
IntrpExecute = function(intrp, stmt)
    throw = StmtAccept(@stmt, @intrp)
    if @throw isa @RuntimeException then return @throw
end function
IntrpResolve = function(intrp, expr, depth)
    intrp[2][@expr] = @depth
end function
// @throwable
IntrpExecuteBlock = function(intrp, statements, environment)
    previous = @intrp[1]
    intrp[1] = @environment
    for statement in @statements
        throw = IntrpExecute(@intrp, @statement)
        if @throw isa @RuntimeException then
            intrp[1] = @previous
            return @throw
        end if
    end for
    intrp[1] = @previous
end function
// @throwable
IntrpVisitBlockStmt = function(intrp, stmt)
    throw = IntrpExecuteBlock(@intrp, @stmt[1], NewEnvironment(@intrp[1]))
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
IntrpVisitClassStmt = function(intrp, stmt)
    superclass = null
    if @stmt[2] != null then
        superclass = IntrpEvaluate(@intrp, @stmt[2])
        if @superclass isa @RuntimeException then return @superclass
        if not (@superclass[0] == "LoxClass") then
            return NewRuntimeError(@stmt[2][1], "Superclass must be a class.")
        end if
    end if

    EnvironmentDefine(@intrp[1], @stmt[1][1], null)

    if stmt[2] != null then
        intrp[1] = NewEnvironment(@intrp[1])
        EnvironmentDefine(@intrp[1], "super", @superclass)
    end if

    methods = {}
    for method in @stmt[3]
        _function = NewLoxFunction(@method, @intrp[1], @method[1][1] == "init")
        methods[@method[1][1]] = @_function
    end for

    klass = NewLoxClass(@stmt[1][1], @superclass, @methods)
    if @superclass != null then
        intrp[1] = @intrp[1][0]
    end if

    throw = EnvironmentAssign(@intrp[1], @stmt[1], @klass)
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
IntrpVisitExpressionStmt = function(intrp, stmt)
    throw = IntrpEvaluate(@intrp, @stmt[1])
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
IntrpVisitFunctionStmt = function(intrp, stmt)
    _function = NewLoxFunction(@stmt, @intrp[1], false)
    throw = EnvironmentDefine(@intrp[1], @stmt[1][1], @_function)
    if @throw isa @RuntimeException then return @throw
end function
// @throwable
IntrpVisitIfStmt = function(intrp, stmt)
    value = IntrpEvaluate(@intrp, @stmt[1])
    if @value isa @RuntimeException then return @value
    if IntrpIsTruthy(@value) then
        throw = IntrpExecute(@intrp, @stmt[2])
        if @throw isa @RuntimeException then return @throw
    else if @stmt[3] != null then
        throw = IntrpExecute(@intrp, @stmt[3])
        if @throw isa @RuntimeException then return @throw
    end if
end function
// @throwable
IntrpVisitSwitchStmt = function(intrp, stmt)
    value = IntrpEvaluate(@intrp, @stmt[1])
    if @value isa @RuntimeException then return @value
    
    matched = false
    isBreak = false

    preIsInSwitch = @intrp[4]
    intrp[4] = true
    for i in range(0, stmt[2].len-1, 1)
        if not @matched then
            condition = IntrpEvaluate(@intrp, @stmt[2][i])
            if @condition isa @RuntimeException then return @condition
        end if 
        if matched or @condition == @value then
            matched = true
            for statement in @stmt[3][i]
                throw = IntrpExecute(@intrp, @statement)
                if @throw isa @Break then 
                    isBreak = true
                    break
                end if
                if @throw isa @RuntimeException then return @throw
            end for
        end if
        if @isBreak then break
    end for

    if @stmt[4] != null and not @isBreak then
        for statement in @stmt[4]
            throw = IntrpExecute(@intrp, @statement)
            if @throw isa @Break then
                isBreak = true
                break
            end if
            if @throw isa @RuntimeException then return @throw
        end for
    end if

    intrp[4] = @preIsInSwitch
end function
// @throwable
IntrpVisitTryStmt = function(intrp, stmt)
    value = IntrpExecute(@intrp, @stmt[1])
    if @value isa @Return or @value isa @Break or @value isa @Continue then return @value

    if @value isa @RuntimeException then
        if @stmt[3] != null then
            if @stmt[2] != null then
                if @value isa @Throw then
                    EnvironmentDefine(@intrp[1], @stmt[2][1], @value.value)
                else
                    EnvironmentDefine(@intrp[1], @stmt[2][1], @value.message)
                end if
            end if

            for statement in @stmt[3][1]
                throw = IntrpExecute(@intrp, @statement)
                if @throw isa @RuntimeException then return @throw
            end for
        end if
    end if

    if @stmt[4] != null then
        throw = IntrpExecute(@intrp, @stmt[4])
        if @throw isa @RuntimeException then return @throw
    end if
end function
// @throwable
IntrpVisitThrowStmt = function(intrp, stmt)
    value = IntrpEvaluate(@intrp, @stmt[1])
    if @value isa @RuntimeException then return @value
    return NewThrow(@value)
end function
// @throwable
IntrpVisitPrintStmt = function(intrp, stmt)
    value = IntrpEvaluate(@intrp, @stmt[1])
    if @value isa @RuntimeException then return @value
    print(IntrpStringify(@value))
end function
// @throwable
IntrpTailCallExecuteBlock = function(intrp, statements)
    for statement in @statements
        throw = IntrpExecute(@intrp, @statement)
        if @throw isa @RuntimeException then return @throw
    end for
end function
// @throwable
IntrpVisitReturnStmt = function(intrp, stmt)
    // tail call optimization
    if @stmt[3] then
        expr = @stmt[2]
        callee = IntrpEvaluate(@intrp, @expr[1])
        if @callee isa @RuntimeException then return @callee
    
        arguments = []
        for argument in @expr[3]
            value = IntrpEvaluate(@intrp, @argument)
            if @value isa @RuntimeException then return @value
            arguments.push(@value)
        end for
    
        if not IsLoxCallable(@callee) then
            return NewRuntimeError(@expr[2], "Can only call functions and classes.")
        end if
    
        if arguments.len != LoxCallableArity(@callee) then
            return NewRuntimeError(@expr[2], "Expected " + LoxCallableArity(@callee) + " arguments but got " + arguments.len + ".")
        end if
        
        if @callee[0] == "LoxFunction" then
            // replace call frame
            intrp[1] = @callee[2]
            for i in range(0, callee[1][2].len - 1, 1)
                EnvironmentDefine(@intrp[1], @callee[1][2][@i][1], @arguments[@i])
            end for

            throw = IntrpTailCallExecuteBlock(@intrp, @callee[1][3])
            if @throw isa @Return then
                if @callee[3] then return EnvironmentGetAt(@callee[2], 0, "this")
                return NewReturn(@throw.value)
            end if
            if @throw isa @RuntimeException then return @throw

            if @callee[3] then return EnvironmentGetAt(@callee[2], 0, "this")
            return null
        else
            throw = LoxCallableCall(@callee, @intrp, @arguments)
            if @throw isa @RuntimeException then return @throw
            return NewReturn(@throw)
        end if
    end if

    value = null
    if @stmt[2] != null then
        value = IntrpEvaluate(@intrp, @stmt[2])
        if @value isa @RuntimeException then return @value
    end if
    return NewReturn(@value)
end function
// @throwable
IntrpVisitVarStmt = function(intrp, stmt)
    value = null
    if @stmt[2] != null then
        value = IntrpEvaluate(@intrp, @stmt[2])
        if @value isa @RuntimeException then return @value
    end if

    EnvironmentDefine(@intrp[1], @stmt[1][1], @value)
end function
// @throwable
IntrpVisitForeachStmt = function(intrp, stmt)
    iterable = IntrpEvaluate(@intrp, @stmt[2])
    if @iterable isa @RuntimeException then return @iterable

    preIsInLoop = @intrp[3]
    intrp[3] = true

    if @iterable isa string then
        for value in @iterable
            EnvironmentDefine(@intrp[1], @stmt[1][1], @value)
            throw = IntrpExecute(@intrp, @stmt[3])
            if @throw isa @Break then break
            if @throw isa @Continue then continue
            if @throw isa @RuntimeException then return @throw
        end for

        intrp[3] = @preIsInLoop
    else if @iterable[0] == "LoxList" then
        for value in @iterable[1]
            EnvironmentDefine(@intrp[1], @stmt[1][1], @value)
            throw = IntrpExecute(@intrp, @stmt[3])
            if @throw isa @Break then break
            if @throw isa @Continue then continue
            if @throw isa @RuntimeException then return @throw
        end for

        intrp[3] = @preIsInLoop
    else if @iterable[0] == "LoxMap" then
        for key in iterable[1].indexes
            // for key:value pair
            EnvironmentDefine(@intrp[1], @stmt[1][1], NewMapExpr({"key": @key, "value": @iterable[1][@key]}))
            throw = IntrpExecute(@intrp, @stmt[3])
            if @throw isa @Break then break
            if @throw isa @Continue then continue
            if @throw isa @RuntimeException then return @throw
        end for

        intrp[3] = @preIsInLoop
    else
        return NewRuntimeError(@stmt[2][1], "Unsupported iterable type " + @iterable[0] + ".")
    end if
end function
// @throwable
IntrpVisitDoWhileStmt = function(intrp, stmt)
    preIsInLoop = @intrp[3]
    intrp[3] = true
    throw = IntrpExecute(@intrp, @stmt[2])
    while IntrpIsTruthy(IntrpEvaluate(@intrp, @stmt[1]))
        throw = IntrpExecute(@intrp, @stmt[2])
        if @throw isa @Break then break
        if @throw isa @Continue then continue
        if @throw isa @RuntimeException then return @throw
    end while
    intrp[3] = @preIsInLoop
end function
// @throwable
IntrpVisitWhileStmt = function(intrp, stmt)
    preIsInLoop = @intrp[3]
    intrp[3] = true
    while IntrpIsTruthy(IntrpEvaluate(@intrp, @stmt[1]))
        throw = IntrpExecute(@intrp, @stmt[2])
        if @throw isa @Break then break
        if @throw isa @Continue then continue
        if @throw isa @RuntimeException then return @throw
    end while
    intrp[3] = @preIsInLoop
end function
// @throwable
IntrpVisitAssignExpr = function(intrp, expr)
    value = IntrpEvaluate(@intrp, @expr[2])
    if @value isa @RuntimeException then return @value

    if @intrp[2].hasIndex(@expr) then
        distance = @intrp[2][@expr]
    else
        distance = null
    end if
    if @distance != null then
        EnvironmentAssignAt(@intrp[1], @distance, @expr[1], @value)
    else
        throw = EnvironmentAssign(@intrp[0], @expr[1], @value)
        if @throw isa @RuntimeException then return @throw
    end if

    return @value
end function
// @throwable
IntrpVisitBinaryExpr = function(intrp, expr)
    left = IntrpEvaluate(@intrp, @expr[1])
    if @left isa @RuntimeException then return @left
    right = IntrpEvaluate(@intrp, @expr[3])
    if @right isa @RuntimeException then return @right
    case = @expr[2][0]
    if case == @TokenType.BANG_EQUAL then return not IntrpIsEqual(@left, @right)
    if case == @TokenType.EQUAL_EQUAL then return IntrpIsEqual(@left, @right)
    if case == @TokenType.GREATER then
        throw = IntrpCheckNumberOperands(@expr[2], @left, @right)
        if @throw isa @RuntimeException then return @throw
        return @left > @right
    end if
    if case == @TokenType.GREATER_EQUAL then
        throw = IntrpCheckNumberOperands(@expr[2], @left, @right)
        if @throw isa @RuntimeException then return @throw
        return @left >= @right
    end if
    if case == @TokenType.LESS then
        throw = IntrpCheckNumberOperands(@expr[2], @left, @right)
        if @throw isa @RuntimeException then return @throw
        return @left < @right
    end if
    if case == @TokenType.LESS_EQUAL then
        throw = IntrpCheckNumberOperands(@expr[2], @left, @right)
        if @throw isa @RuntimeException then return @throw
        return @left <= @right
    end if
    if case == @TokenType.MINUS then
        throw = IntrpCheckNumberOperands(@expr[2], @left, @right)
        if @throw isa @RuntimeException then return @throw
        return @left - @right
    end if
    if case == @TokenType.PLUS then
        if @left isa number and @right isa number then return @left + @right
        if @left isa string and @right isa string then return @left + @right
        if @left[0] == "LoxList" and @right[0] == "LoxList" then return NewLoxList(@left[1] + @right[1])
        if @left[0] == "LoxMap" and @right[0] == "LoxMap" then return NewLoxMap(@left[1] + @right[1])
        return NewRuntimeError(@expr[2], "Unsupported operand types" + @left[0] + " and " + @right[0] + ".")
    end if
    if case == @TokenType.SLASH then
        throw = IntrpCheckNumberOperands(@expr[2], @left, @right)
        if @throw isa @RuntimeException then return @throw
        if @right == 0 then return NewRuntimeError(@expr[2], "Division by zero.")
        return @left / @right
    end if
    if case == @TokenType.STAR then
        if @left isa number and @right isa number then return @left * @right
        if @left isa string and @right isa number then return @left * @right
        if @left[0] == "LoxList" and @right isa number then return NewLoxList(@left[1] * @right)
        return NewRuntimeError(@expr[2], "Unsupported operand types" + @left[0] + " and " + @right[0] + ".")
    end if
    if case == @TokenType.MOD then
        throw = IntrpCheckNumberOperands(@expr[2], @left, @right)
        if @throw isa @RuntimeException then return @throw
        if @right == 0 then return NewRuntimeError(@expr[2], "Division by zero.")
        return @left % @right
    end if
    return null
end function
// @throwable
IntrpVisitTenaryExpr = function(intrp, expr)
    condition = IntrpEvaluate(@intrp, @expr[1])
    if @condition isa @RuntimeException then return @condition
    if IntrpIsTruthy(@condition) then
        return IntrpEvaluate(@intrp, @expr[2])
    else
        return IntrpEvaluate(@intrp, @expr[3])
    end if
end function
// @throwable
IntrpVisitCallExpr = function(intrp, expr)
    callee = IntrpEvaluate(@intrp, @expr[1])
    if @callee isa @RuntimeException then return @callee

    arguments = []
    for argument in @expr[3]
        value = IntrpEvaluate(@intrp, @argument)
        if @value isa @RuntimeException then return @value
        arguments.push(@value)
    end for

    if not IsLoxCallable(@callee) then
        return NewRuntimeError(@expr[2], "Can only call functions and classes.")
    end if

    if arguments.len != LoxCallableArity(@callee) then
        return NewRuntimeError(@expr[2], "Expected " + LoxCallableArity(@callee) + " arguments but got " + arguments.len + ".")
    end if

    return LoxCallableCall(@callee, @intrp, @arguments)
end function
// @throwable
IntrpVisitGetExpr = function(intrp, expr)
    object = IntrpEvaluate(@intrp, @expr[1])
    if @object isa @RuntimeException then return @object

    if @object isa string then
        if StrIntrs.hasIndex(@expr[2][1]) then
            strIntr = @StrIntrs[@expr[2][1]]
            if @strIntr[3] then 
                ret = @strIntr[2]
                return ret(@object, @intrp, null)
            else
                strIntr.push(@object)
                return @strIntr
            end if
        end if
        return NewRuntimeError(@expr[2], "String has no property '" + @expr[2][1] + "'.")
    end if
    if @object[0] == "LoxInstance" then
        return LoxInstanceGet(@object, @expr[2])
        // return @object[1][@expr[3][1]]
    end if
    if @object[0] == "LoxList" then
        if ListIntrs.hasIndex(@expr[2][1]) then
            listIntr = @ListIntrs[@expr[2][1]]
            if @listIntr[3] then 
                ret = @listIntr[2]
                return ret(@object, @intrp, null)
            else
                listIntr.push(@object)
                return @listIntr
            end if
        end if
        return NewRuntimeError(@expr[2], "List has no property '" + @expr[2][1] + "'.")
    end if
    if @object[0] == "LoxMap" then
        if MapIntrs.hasIndex(@expr[2][1]) then
            mapIntr = @MapIntrs[@expr[2][1]]
            if @mapIntr[3] then 
                ret = @mapIntr[2]
                return ret(@object, @intrp, null)
            else
                mapIntr.push(@object)
                return @mapIntr
            end if
        end if
        return NewRuntimeError(@expr[2], "Map has no property '" + @expr[2][1] + "'.")
    end if

    return NewRuntimeError(@expr[3], "Get not supported on " + @object[0] + ".")
end function
// @throwable
IntrpVisitSubscriptExpr = function(intrp, expr)
    object = IntrpEvaluate(@intrp, @expr[1])
    if @object isa @RuntimeException then return @object
    index = IntrpEvaluate(@intrp, @expr[2])
    if @index isa @RuntimeException then return @index

    
    if @object[0] == "LoxList" then
        return LoxListGet(@object, @index, @expr[3])
    end if
    if @object[0] == "LoxMap" then
        return LoxMapGet(@object, @index, @expr[3])
    end if
    if @object isa @string then
        if @index < 0 then index = object.len + @index
        if @index < 0 or @index >= object.len then
            return NewRuntimeError(@expr[3], "Index " + @index + " out of bounds.")
        end if
        return @object[@index]
    end if
    return NewRuntimeError(@expr[3], "Subscript not supported on " + @object[0] + ".")
end function
// @throwable
IntrpVisitSliceExpr = function(intrp, expr)
    object = IntrpEvaluate(@intrp, @expr[1])
    if @object isa @RuntimeException then return @object

    start = 0
    if @expr[2] != null then
        start = IntrpEvaluate(@intrp, @expr[2])
        if @start isa @RuntimeException then return @start
    end if

    if @object[0] == "LoxList" then
        _end = object[1].len
        if @expr[3] != null then
            _end = IntrpEvaluate(@intrp, @expr[3])
            if @_end isa @RuntimeException then return @_end
        end if

        throw = LoxListInbounds(@object, @start, @expr[2])
        if @throw isa @RuntimeException then return @throw
        throw = LoxListInbounds(@object, @_end - 1, @expr[3])
        if @throw isa @RuntimeException then return @throw
        return NewLoxList(@object[1][@start:@_end], @object[2])
    end if

    if @object isa @string then
        _end = object.len
        if @expr[3] != null then
            _end = IntrpEvaluate(@intrp, @expr[3])
            if @_end isa @RuntimeException then return @_end
        end if

        if @start < 0 then @start = object.len + @start
        if @start < 0 or @start >= object.len then
            return NewRuntimeError(@expr[2], "Index " + @start + " out of bounds.")
        end if
        if @_end < 0 then @_end = object.len + @_end
        if @_end < 0 or @_end > object.len then
            return NewRuntimeError(@expr[3], "Index " + @_end + " out of bounds.")
        end if
        return @object[@start:@_end]
    end if

    return NewRuntimeError(@expr[4], "Slice not supported on " + @object[0] + ".")
end function
// @throwable
IntrpVisitGroupingExpr = function(intrp, expr)
    return IntrpEvaluate(@intrp, @expr[1])
end function
IntrpVisitLiteralExpr = function(intrp, expr)
    return @expr[1]
end function
// @throwable
IntrpVisitLambdaExpr = function(intrp, expr)
    return NewLoxFunction(@expr, @intrp[1], false)
end function
// @throwable
IntrpVisitListExpr = function(intrp, expr)
    _values = []
    for value in @expr[1]
        value = IntrpEvaluate(@intrp, @value)
        if @value isa @RuntimeException then return @value
        _values.push(@value)
    end for
    return NewLoxList(@_values)
end function
// @throwable
IntrpVisitMapExpr = function(intrp, expr)
    map = {}
    for key in expr[1].indexes
        value = @expr[1][@key]

        key = IntrpEvaluate(@intrp, @key)
        if @key isa @RuntimeException then return @key
        value = IntrpEvaluate(@intrp, value)
        if @value isa @RuntimeException then return @value
        map[@key] = @value
    end for
    return NewLoxMap(@map)
end function
// @throwable
IntrpVisitLogicalExpr = function(intrp, expr)
    left = IntrpEvaluate(@intrp, @expr[1])
    if @left isa @RuntimeException then return @left

    if @expr[2][0] == @TokenType.OR then
        if IntrpIsTruthy(@left) then return @left
    else if not IntrpIsTruthy(@left) then 
        return @left
    end if
    return IntrpEvaluate(@intrp, @expr[3])
end function
// @throwable
IntrpVisitSetExpr = function(intrp, expr)
    object = IntrpEvaluate(@intrp, @expr[1])
    if @object isa @RuntimeException then return @object

    if @object[0] != "LoxInstance" then
        return NewRuntimeError(@expr[3], "Only instances have fields.")
    end if

    value = IntrpEvaluate(@intrp, @expr[3])
    if @value isa @RuntimeException then return @value
    LoxInstanceSet(@object, @expr[2], @value)
    return @value
end function
// @throwable
IntrpVisitSubscriptSetExpr = function(intrp, expr)
    object = IntrpEvaluate(@intrp, @expr[1])
    if @object isa @RuntimeException then return @object
    index = IntrpEvaluate(@intrp, @expr[2])
    if @index isa @RuntimeException then return @index

    value = IntrpEvaluate(@intrp, @expr[3])
    if @value isa @RuntimeException then return @value

    if @object[0] == "LoxList" then
        throw = LoxListSet(@object, @index, @value, @expr[4])
        if @throw isa @RuntimeException then return @throw
        return @object
    end if
    if @object[0] == "LoxMap" then
        LoxMapSet(@object, @index, @value)
        return @object
    end if
    if @object isa @string then
        if @index < 0 then index = object.len + @index
        if @index < 0 or @index >= object.len then
            return NewRuntimeError(@expr[4], "Index " + @index + " out of bounds.")
        end if
        throw = IntrpCheckNumberOperand(@expr[4], @value)
        if @throw isa @RuntimeException then return @throw
        object[@index] = @value
        return @object
    end if
    return NewRuntimeError(@expr[4], "Subscript not supported on " + @object[0] + ".")
end function
// @throwable
IntrpVisitSuperExpr = function(intrp, expr)
    if @intrp[2].hasIndex(@expr) then
        distance = @intrp[2][@expr]
    else
        distance = null
    end if
    superClass = EnvironmentGetAt(@intrp[1], @distance, "super")

    object = EnvironmentGetAt(@intrp[1], @distance - 1, "this")

    method = LoxClassFindMethod(@superClass, @expr[2][1])

    if @method == null then
        return NewRuntimeError(@expr[2], "Undefined property '" + @expr[2][1] + "'.")
    end if

    return LoxFunctionBind(@method, @object)
end function
IntrpVisitThisExpr = function(intrp, expr)
    return IntrpLookupVariable(@intrp, @expr[1], @expr)
end function
// @throwable
IntrpVisitUnaryExpr = function(intrp, expr)
    right = IntrpEvaluate(@intrp, @expr[2])
    case = @expr[1][0]
    if @case == "BANG" then 
        return not IntrpIsTruthy(@right)
    else if @case == "MINUS" then
        throw = IntrpCheckNumberOperand(@expr[1], @right)
        if @throw isa @RuntimeException then return @throw
        return -@right
    end if
end function
// @throwable
IntrpVisitPrefixExpr = function(intrp, expr)
    throw = IntrpEvaluate(@intrp, @expr[3])
    if @throw isa @RuntimeException then return @throw

    return IntrpEvaluate(@intrp, @expr[1])
end function
// @throwable
IntrpVisitPostfixExpr = function(intrp, expr)
    value = IntrpEvaluate(@intrp, @expr[1])
    if @value isa @RuntimeException then return @value

    throw = IntrpEvaluate(@intrp, @expr[3])
    if @throw isa @RuntimeException then return @throw
    return @value
end function
// @throwable
IntrpVisitVariableExpr = function(intrp, expr)
    return IntrpLookupVariable(@intrp, @expr[1], @expr)
end function
IntrpLookupVariable = function(intrp, _name, expr)
    if @intrp[2].hasIndex(@expr) then
        distance = @intrp[2][@expr]
    else
        distance = null
    end if
    if @distance != null then
        return EnvironmentGetAt(@intrp[1], @distance, @_name[1])
    end if
    return EnvironmentGet(@intrp[0], @_name)
end function
// @throwable
IntrpCheckNumberOperand = function(operator, operand)
    if @operand isa number then return
    return NewRuntimeError(@operator, "Operand must be a number.")
end function
// @throwable
IntrpCheckNumberOperands = function(operator, left, right)
    if @left isa number and @right isa number then return
    return NewRuntimeError(@operator, "Operands must be numbers.")
end function
IntrpIsTruthy = function(object)
    if @object == null then return false
    if @object isa number then return @object != 0
    return true
end function
IntrpIsEqual = function(a, b)
    if @a == null and @b == null then return true
    if @a == null then return false
    return @a == @b
end function
IntrpStringify = function(object)
    if @object == null then return "nil"
    
    // if @object isa number then
    //     return str(@object)
    // end if
    return str(@object)
end function
interpreter = NewInterpreter()
// lox
hadError = false
hadRuntimeError = false
LoxErrorLM = function(line, message)
    print(@line + " " + @message)
end function
LoxErrorTM = function(token, message)
    if @token[0] == @TokenType.EOF then
        LoxReport(@token[3], " at end", @message)
    else
        LoxReport(@token[3], " at '" + @token[1] + "'", @message)
    end if
end function
LoxReport = function(line, where, message)
    print("[line " + @line + "] Error" + @where + ": " + @message)
    globals.hadError = true
end function
// exception
RuntimeException = {}
RuntimeError = new @RuntimeException
NewRuntimeError = function(token, message)
    ret = new @RuntimeError
    ret.token = @token
    ret.message = @message
    return @ret
end function
ParseError = new RuntimeException
NewParseError = function
    ret = new @ParseError
    return @ret
end function
Break = new RuntimeException
NewBreak = function
    ret = new @Break
    return @ret
end function
Continue = new RuntimeException
NewContinue = function
    ret = new @Continue
    return @ret
end function
Return = new RuntimeException
NewReturn = function(value)
    ret = new @Return
    ret.value = @value
    return @ret
end function
Throw = new RuntimeException
NewThrow = function(value)
    ret = new @Throw
    ret.value = @value
    return @ret
end function
LoxRuntimeError = function(error)
    print("[line " + @error.token[3] + "] " + @error.message)
    globals.hadRuntimeError = true
end function
// run
run = function(source)
    scanner = NewScanner(@source)
    tokens = ScanTokens(@scanner)
    
    // for token in @tokens
    //     print(TokenToString(@token))
    // end for
    // return

    parser = NewParser(@tokens)
    statements = Parse(@parser)
    if @hadError then return
    
    resolver = NewResolver(@interpreter)
    throw = ResolverResolve(@resolver, @statements)
    if @throw isa @RuntimeException then return @throw
    if @hadError then return

    Interpret(@interpreter, @statements)
end function
runPrompt = function
    while true
        line = user_input("> ")
        if line.len == 0 then break
        run(@line)
        globals.hadError = false
    end while
end function
runSource = function(source)
    run(@source)
    if @hadError then return 65
    if @hadRuntimeError then return 70
    return 0
end function
IntrpUnitTests = function
    forloop = [
        "var s = clock();",
        "for (var i = 1; i <= 1000; i = i + 1) {",
            "print i;",
        "}",
        "print clock() - s;",
    ]
    whileloop = [
        "var s = clock();",
        "var i = 1;",
        "while (i <= 1000) {",
            "print i;",
            "i = i + 1;",
        "}",
        "print clock() - s;",
    ]
    classInheritance = [
        "class Animal {",
        "  init(name) {",
        "    this.name = name;",
        "  }",
        "  speak() {",
        "    print this.name + "" makes a noise."";",
        "  }",
        "}",
        "class Dog < Animal {",
        "  init(name, breed) {",
        "    super.init(name);",
        "    this.breed = breed;",
        "  }",
        "  speak() {",
        "    print this.name + "" barks. It is a "" + this.breed + ""."";",
        "  }",
        "}",
        "var myDog = Dog(""Buddy"", ""Golden Retriever"");",
        "myDog.speak(); // Buddy barks. It is a Golden Retriever.",
        "var myAnimal = Animal(""Generic Animal"");",
        "myAnimal.speak();",
    ]
    fibonacci = [
        "fun fib(n) {",
        "  if (n <= 1) return n;",
        "  return fib(n - 1) + fib(n - 2);",
        "}",
        "var s = clock();",
        "print fib(1);",
        "print clock() - s;",
    ]
    tailCall = [
        "fun f(n, acc) {",
        "  if (n <= 1) return acc;",
        "  return f(n - 1, acc + 1);",
        "}",
        "var s = clock();",
        "print f(1000, 0);",
        "print clock() - s;",
    ]
    foreach = [
        "var l = [1, 2, 3, 4, 5];",
        "foreach (var i in l) {",
        "  print i;",
        "}",
    ]
    dowhile = [
        "var i = 0;",
        "do {",
        "  print i;",
        "  i = i + 1;",
        "} while (i < 5);",
    ]
    breakContinue = [
        "var i = 0;",
        "while (i < 5) {",
        "  print i;",
        "  i = i + 1;",
        "  if (i == 3) break;",
        "}",
        "i = 0;",
        "while (i < 5) {",
        "  i = i + 1;",
        "  if (i == 3) continue;",
        "  print i;",
        "}",
    ]
    elseif = [
        "var x = 3;",
        "if (x == 0) {",
        "  print ""x is 0"";",
        "} else if (x == 1) {",
        "  print ""x is 1"";",
        "} else {",
        "  print ""x is not 0 or 1"";",
        "}",
    ]
    lambda = [
        "var f = [lambda (x) {",
        "  return x + 1;",
        "}];",
        "print f[0](1);",
    ]
    swich = [
        "var x = 3;",
        "switch (x) {",
        "  case 0: print ""x is 0"";",
        "  case 1: print ""x is 1"";",
        "  default: print ""x is not 0 or 1"";",
        "}",
    ]
    try = [
        "try {",
        "  throw ""error"";",
        "} catch (var e) {",
        "  print e;",
        "}",
    ]
    listOprations = [
        "var l = [1, 2];",
        "print l*2;",
        "print l+[3, 4];",
    ]
    mapOprations = [
        "var a = {""a"": 1, ""b"": 2};",
        "var b = {""a"": 2, ""c"": 3, ""d"": 4};",
        "print a + b;",
    ]
    augOprations = [
        "var a = 1;",
        "print a++;",
        "print ++a;",
        "a -= 1;",
        "print a;",
        "print a % 2;",
    ]
    tenary = [
        "var x = 3;",
        "print x == 3 ? ""x is 3"" : ""x is not 3"";",
    ]
    intrinsic = [
		"print pi;",
    ]
    runSource(intrinsic.join(char(10)))
end function
IntrpUnitTests